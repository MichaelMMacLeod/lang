; language 1 (boolean values and boolean logical operations)

  (true  -> true)
  (false -> false)

  ; Most languages define the usual boolean operators on a fixed
  ; number of arguments. Because (1) these operators also have
  ; sensible definitions for arbitrary numbers of arguments, (2) it is
  ; not too hard to define them that way here, (3) supporting
  ; arbitrary numbers of arguments makes certain programs much easier
  ; to express (e.g, (and a b c d e f g) to check if the arguments are
  ; all true instead of (and a (and b (and c (and d (and e (and f
  ; g)))))) or (foldl and true (list a b c d e f g)), (4) supporting
  ; arbitrary numbers of arguments does not seem to make programs less
  ; easy to understand, and (5) it makes lifting these operations a
  ; lot easier because there is no need to remember the number of
  ; arguments, the choice has been made to define these operations as
  ; taking arbitrary numbers of arguments.

         (none-false      -> and)
        ((and)            -> true)
  (for b (and false b ..) -> false)
  (for b (and true b ..)  -> (and b ..))

         (none-true       -> not)
         (nor             -> not)
        ((not)            -> true)
  (for b (not true b ..)  -> false)
  (for b (not false b ..) -> (not b ..))

         (not-all-true     -> nand)
        ((nand)            -> false)
  (for b (nand false b ..) -> true)
  (for b (nand true b ..)  -> (nand b ..))

         (not-all-false) -> or
        ((or)            -> false)
  (for b (or true b ..)  -> true)
  (for b (or false b ..) -> (or b ..))

             (all-equal -> =)
             (xnor      -> =)

         (not-all-equal -> xor)
  (for b (xor b ..)     -> (not (= b ..)))

          ((implies)        -> false)
  (for p c (implies p .. c) -> (or (not p) .. c))

; language 1.25 (boolean ordering operations)

  ; It is not uncommon to think of 'true' being 'one' and 'false'
  ; being 'zero'. This is often defined to be the case in C/C++, for
  ; example---although the opposite is also often the case, e.g., bash
  ; return codes, where 'zero' means 'success' or 'true' and 'one' (or
  ; any number at least 'one') means 'failure' or 'false'. Ultimately
  ; it is of no importance which way 'true' and 'false' are defined so
  ; long as it is not ambiguous which way they are defined. We take
  ; the choice of 'true' being 'one' and 'false' being 'zero' here
  ; because in other places when we lift '<' and interpret its
  ; operands as types, it is more common to think of '(< T1 T2)' as
  ; meaning 'T1 is a strict subtype of T2' and not 'T2 is a strict
  ; subtype of T1'. The conversion to 'one' and 'zero' is not given
  ; here, but ordering operators will be defined in its place.

        ((<)                      -> true)
        ((< true)                 -> true)
        ((< false)                -> true)
  (for b (< true true b ..)       -> false)
  (for b (< true false b ..)      -> false)
  (for b (< false false b ..)     -> false)
  (for b (< false true b ..)      -> (< true b ..))

        ((>)                      -> true)
        ((> true)                 -> true)
        ((< false)                -> true)
  (for b (> false true b ..)      -> false)
  (for b (> true true b ..)       -> false)
  (for b (> false false b ..)     -> false)
  (for b (> true false b ..)      -> (> true b ..))

        ((<=)                     -> true)
        ((<= true)                -> true)
        ((<= false)               -> true)
  (for b (<= true false b ..)     -> false)
  (for b (<= true true)           -> (<= true b ..))
  (for b (<= false true b ..)     -> (<= true b ..))
  (for b (<= false false)         -> (<= false b ..))
                                  
        ((>=)                     -> true)
        ((>= true)                -> true)
        ((>= false)               -> true)
  (for b (>= false true b ..)     -> false)
  (for b (>= true true b ..)      -> (>= true b ..))
  (for b (>= true false b ..)     -> (>= true b ..))
  (for b (>= false false b ..)    -> (>= false b ..))

; language 1.4 (aliases for ordering operations)

  (strictly-decreasing     -> >)
  (strictly-increasing     -> <)
  (non-strictly-decreasing -> >=)
  (non-strictly-increasing -> <=)

; language 1.5 (default definitions for ordering operations)

  ; Defines '>=', '<=', and '>' in terms of '<' (and some boolean
  ; operations) to aid in the implementation of custom orderings.

  (for x (>= x ..) -> (not (< x ..)))
  (for x (<= x ..) -> (or (< x ..) (= x ..)))
  (for x (> x ..)  -> (nor (< x ..) (= x ..)))

; language 2 (top and bottom types and type operations) [imports 1, 1.5]

  (any -> (lift true))
  (nothing -> (lift false))

  ((lift true) -> (lift true))
  ((lift false) -> (lift false))

  (for t (lower (lift t)) -> t)

  (for op (lift-op op ..) ->
    (begin (for p (op p ..) ->
             (op (lower p) ..))
           ..))

  (lift-op and not nand or xor implies =)

  (for t (< t nothing) -> false)
  (for t (< t any) -> (not (>= t any)))

  (for v t (the (<= v t)) -> (the (<= t v)))
  (for v t (the t v) -> (implies (<= v t) (the (<= t v))))

  (for b (< b)                    -> true)
  (for b (< any nothing b ..)     -> false)
  (for b (< nothing nothing b ..) -> false)
  (for b (< any any b ..)         -> false)
  (for b (< nothing any b ..)     -> (< any b ..))

; language 22 (well-typed and ill-typed types and operations)

  (well-typed -> (lift any))
  (ill-typed -> (lift nothing))

  ((lift any) -> (lift any))
  ((lift nothing) -> (lift nothing))

  (for t (lower2 (lift (lift t))) -> t)

  (for op (lift2-op op ..) ->
    (begin (for p (op p ..)
             (op (lower2 p) ..)
             ..)))

  (lift2-op and not nand or xor implies =)

  (for t (< t well-typed) -> (not (>= t well-typed)))

; language 3 (the type boolean) [imports 2]

  (boolean -> boolean)

  (for t (< t boolean) -> (or (= t true) (= t false)))

  (for b (< boolean any b ..) -> (< any b ..))
  (for b (< nothing boolean b ..) -> (< b ..))

  (for op (annotate-with-types t op ..) ->
    (begin
      (for v (prove < (op v ..) t)
        (implies (and (prove < v t) ..)
          (< (op v ..) t)))))

  (annotate-with-types boolean
    and nor nand or xor implies < > <= >= =)

  (for v (prove < (and v ..) boolean)
    (implies (and (prove < v boolean) ..)
      (< (and v ..) boolean)))

  (prove <= undefined-lol any)
  (impl prove <= undefined-lol any)
  (> undefined-lol any) ; e.g., this is not a defined term in our language

  (for t (impl <= t any) ->
    (let (i -> (<= t any))
      (catch ((irreducible i) -> (> t any))
        (<= t any))))


  ; (new delimiter <handler>) -> <delimiter>
  ; (<delimiter> <body>) -> <body-delimited>

  Evaluating '~' terms eagerly in rule terms


    (for contains~terms
      (remove-all~terms contains~terms) ->
      (let (all~terms ->
             (new environment
               (for m (~ m ..) ->
                 (raise (~ m ..)))))
        (catch (for m (~ m ..) -> (m ..))
               (for no~terms env
                 (irreducible no~terms env) ->
                 no~terms)
          (with-environment (and this-environment all~terms)
            contains~terms))))

    (remove-all~terms (~ and true false))
    -->
    (let (all~terms ->
           (new environment
             (for m (~ m ..) ->
               (raise (~ m ..)))))
      (catch (for m (~ m ..) -> (m ..))
             (for no~terms env
               (irreducible no~terms env) ->
               no~terms)
        (with-environment (and this-environment all~terms)
          (~ and true false))))
    -->
    (catch (for m (~ m ..) -> (m ..))
           (for no~terms env
             (irreducible no~terms env) ->
             no~terms)
      (with-environment (and this-environment all~terms)
        (~ and true false)))
    -->
    

    (for v p r (dyn v .. p -> r) ->
      (remove-all~terms
        (for v .. p -> r)))


    (for contains~terms (remove-all~terms contains~terms) ->
      (let (all~terms -> (new environment (val m (~ m ..))))
        (catch (for m env (irreducible m env) -> m)
          (with-environment (and current-environment all~terms)
            contains~terms))))

    (for m
      (for~parser (~incomplete m)) ->
      )

    (for m
      (for-tilde-parser (~literal m) ->
        (~literal m)))
    (for m
      (for-tilde-parser (~ m ..)) ->
      (seq (m ..)
           (~literal (m ..))))
    

    (for v p r
      (dyn v .. p -> r) ->
      )
    

  Fixed points

    (for v f (val v .. f) -> (for v .. f -> f))

  Dynamic rules

    (for v p p-f p-i
           r r-f r-i
      (dyn v .. (~ val p p-f p-i) -> (~val r r-f r-i))
      (val p )
    (for v p r
      (dyn v .. (~val p) -> (~val r)) ->
      (val p (val r (for v .. p -> r))))
    (for v p r
      (dyn v .. p -> (val r)) ->
      (seq r (for v .. p -> r)))
    (for v p r
      (dyn v .. (val p) -> r) ->
      (seq p (for v .. p -> r)))

  Rules for declaring fixed-points

    (for v pr
      (for. v .. pr .) ->
      (for v .. pr -> pr))
    (for v p r
      (for. v .. p -> r) ->
      (for v .. p -> r))

  Rules for throwing and catching exceptions

    (for e (exception e) -> (exception e))
    (sequence (new delimiter)
      (for catch-delimiter -> (new delimiter)))
    (for e (raise e) -> (abort catch-delimiter (exception e)))
    (for v (try v) ->
      (delimit catch-delimiter
               (for e (exception e) -> (err e))
        (ok v)))
    (for c v (catch c .. v) ->
      (delimit catch-delimiter
               (for e (exception e) ->
                 (let c .. e))
               v))


    (catch (for A -> 10)
      (catch (for A -> 100)
        (raise A)))
    -->
    (delimit catch-delimiter
             (for e (exception e) ->
               (let (A -> 10)
                 e))
      (catch (for A -> 100)
        (raise A)))
    -->
    (catch (for A -> 100)
      (raise A))
    -->
    (delimit catch-delimiter)
              


    (catch (for A -> 10)
           (for B -> 100)
      (raise A))
    -->
    (delimit catch-delimiter
             (for e (exception e) ->
               (let (for A -> 10)
                    (for B -> 100)
                 e))
             (raise A))
    -->
    (delimit <delimiter>
             (for e (exception e) ->
               (let (for A -> 10)
                    (for B -> 100)
                 e))
             (raise A))
    -->
    (delimit <delimiter>
             <rule>
             (raise A))
    -->
    (raise A)
    -->
    (abort catch-delimiter (exception A))
    -->
    (abort <delimiter> (exception A))
    -->
    (let (for A -> 10)
         (for B -> 100)
      A)
    -->
    A
    -->
    10
    



    (sequence (new unique identifier)
      (for catch-delimiter -> (new unique identifier)))


    (for catcher body
      (catch catcher .. body) ->
      (delimit catch-delimiter))

    
    (sequence catch-delimiter
      (for catch-delimiter -> (new delimiter)))

    (sequence (new unique symbol)
      (let (dynamic -> (new unique symbol))
        (let (body -> dynamic)
          (sequence dynamic
            (let (dynamic -> A)
              body)))))
    -->
    (let (dynamic -> unique-symbol#12345)
      (let (body -> dynamic)
        (sequence dynamic
          (let (dynamic -> A)
            body))))
    -->
    (let (body -> dynamic)
      (sequence dynamic
        (let (dynamic -> A)
          body)))
    -->
    (sequence dynamic
      (let (dynamic -> A)
        body))
    -->
    (let (unique-symbol#12345 -> A)
      body)
    -->
    body
    -->
    dynamic
    -->
    unique-symbol#12345
    -->
    A


    (sequence catch-delimiter
      (let (catch-delimiter -> A)
        catch-delimiter))
    (for e (throw e) -> (abort catch-delimiter e))
    (for c b
      (catch c .. b) ->
      (sequence catch-delimiter
        (let (catch-delimiter ))))

    (seq (new delimiter)
      (for exception-delimiter (new delimiter)))
    (for e (throw e) ->
      (abort exception-delimiter e))
    (for catcher body
      (catch catcher .. body) ->
      (seq exception-delimiter
        (seq (new delimiter)
          (let (for exception-delimiter ->)))))

  Rules which eagerly reduce their patterns and results

    (for v p0 p1 p r0 r1 r
      (for~ v .. (~ p0 p1 p ..) -> (~ r0 r1 r ..)) ->
      (seq (p0 p1 p ..)
           (seq (r0 r1 r ..)
                (for. v .. (p0 p1 p ..) -> (r0 r1 r ..)))))
    (for v p r0 r1 r
      (for~ v .. (. p) -> (~ r0 r1 r ..)) ->
      (seq (r0 r1 r)
           (for v .. p -> (r0 r1 r ..))))
    (for v p r
      (for~ v .. (. p) -> (. r)) ->
      (for. v .. p -> r))
    (for v pr
      (for~ v .. pr .) ->
      (for. v .. pr .))

  Rules for throwing and catching exceptions

    (for~ e (uncaught-exception e) .)
    (for~ (. exception-delimiter) -> ())

  Throwing and catching exceptions: '(catch handler .. body)' and
  '(raise exception)'.

    (for. e (uncaught-exception e) .)
    (for. exception-delimiter -> ())



    

    (val e (uncaught-exception e))
    (dyn exception-delimiter -> (new continuation-delimiter))
    (dyn (val exception-delimiter) ->
      (new-continuation-delimiter
        (for (exception e) ->
          (uncaught-exception e))))
    (for e (raise e) ->
      (continuation-delimit exception-delimiter e))
    (for catcher body (catch c .. v) ->
      (let (dyn (~reduce exception-delimiter) ->
             (new delimiter
               (for (exception e) ->
                 (let c .. e))))
        body))



    (for c v (catch c .. v) ->
      (let (dyn e )))

  (for e (uncaught-exception e) .)

  

  (dyn current-exception-delimiter (~reduce (new unique symbol)))
  (dyn )




  (for exception-delimiter -> (~reduce (new unique term)))
  (for (~reduce exception-delimiter) ->
    )

  (for exception-delimiter -> dyn
    (new unique term))
  (dyn exception-handler ->
    (for e (exception e) ->
      (uncaught-exception e)))



  (for v d r (dyn v .. d r) -> (for v .. (#%reduce d) -> r))
  (for e (uncaught-exception e) .)
  (dyn exception-delimiter ->
    (for e (exception e) ->
      ))

  (for (#%reduce exception-delimiter) ->
    (for e (exception e) ->
      ()))


  (for (#%reduce-once exception-delimiter) ->
    (for e (exception e)
      (uncaught-exception e)))

  (#%reduce (+ 1 (* 2 3)))
  (#%incomplete (+ 1 (#%reduce (* 2 3))))
  (#%reduce (+ 1 6))
  7




  (+ 1 (* 2 3))
  (#%reduce (+ 1 (* 2 3)))
  ((#%reduce +) 1 (* 2 3))
  ((#%irreducible +) (#%reduce 1) (* 2 3))
  (#%reduce ((#%irreducible +) (#%done 1) (* 2 3)))
  ((#%irreducible +)
   (#%done 1)
   (#%reduce (* 2 3)))
  ((#%irreducible +)
   (#%done 1)
   ((#%reduce )))

  (reduce>>> reduce (+ 1 (* 2 3)))
  (>>> reducing (+ (#%reduce 1) (* 2 3)))
  (>>> reducing (+ (#%done 1) (#%reducing (* 2 3))))
  (#%reduce (+ (#%done 1) (* 2 3)))
  (+ (#%done 1)
     (* (#%reduce 2) 3))
  (#%reduce (+ 1 (* 2 3)))
  

  (dyn exception-delimiter ->
    (new delimiter
      (for e (exception e) ->
        ())))

  (for catcher body )

  (for catcher body (catch catcher .. body)
    (dynamic-let (exception-delimiter ->
                   (new delimiter
                     (for e (exception e)
                       (let catcher .. e))))
      (delimit body exception-delimiter)))

  (for e (raise e)
    (abort exception-delimiter e))


  (catch (A -> 100)
    (raise A))
  -->
  (let (d -> (new delimiter
               (for ))))


  (for abort-handler body (new continuation-delimiter abort-handler body) ->
    (dynamic-let (exception-delimiter -> (new continuation-delimiter))
      (continuation-delimit exception-delimiter)))

  (for catcher body (catch catcher .. body) ->
    (new continuation-delimiter
      (for e (exception e) ->
        (let catcher .. e))
      body))







  (current-exception-delimiter ->
    (new continuation-delimiter))

  (current-catcher ->
    (for e (exception e) ->
      (raise e)))

    (dynamic-let (current-exception-delimiter ->
                   (new delimiter))
      (new continuation-delimiter
        )
      (continuation-delimit current-exception-delimiter
        (for e (exception e)
          (let catcher .. e))
        ))


    (dynamic-let (current-catcher ->
                   (for e (exception e)
                     (let handler .. e)))
      body))

  (for e (raise e) ->
    (abort current-catcher))

  (catch (A -> 10)
         (B -> 100)
    (raise A))

  (for handler body (catch handler .. body) ->
    (dynamic-let (for exception (exception-handler exception) ->
                   (let handler .. exception))
      body))


  (<= surprise any)
  (let (i -> (<= #0=surprise any))
    (catch ((irreducible i) -> (> #0# any))
      (impl <= #0# any)))
  (let-handlers ((irreducible i) -> (> #0=surprise any))
    (impl <= #0# any))
  (impl <= surprise any)
  (continuation-abort current-catch
    (irreducible (impl <= surprise any)))
  (let ((irreducible #1=(impl <= #0=surprise any)) -> (> #0# any))
    (irreducible #1#))
  (irreducible (impl <= surprise any))
  (> surprise any)

  (for t (<= t any)
    (let (i (<= t any))
      (let-handlers (for (irreducible i) (> t any))
        (impl <= t any))))

  (<= Surprise! any)
  (let (i #0=(<= #1=Surprise! any))
    (let-handlers (for (irreducible i) (> #1# any))
      (impl <= #1# any )))



    (let-handlers (impl <= t any)
      (for term (irreducible term)
        ())
    (let-dynamic [current-abort-handler
                  (for term (irreducible term)
                    )]))

  (for op v t (prove op v t)
    (let [i -> (impl prove op v t)]
      (and (<= i any) i))

  (for op v t (prove op v t)
    (with-handlers [for v (irreducible v)]))

  (prove < (and true false) boolean)
  (let [i (impl prove < (and true false) boolean)]
    (and (<= i any) i))
  (and (<= i any) i)
  (and (<= #0=(impl prove < (and true false) boolean)
           any)
       #0#)
  (and ())


    (and (prove < (impl prove op v t) any)
         (prove ))
    (let [d ]
      (if d (the d) d)))

  (for v t (prove < (+ v ..) t)
    (implies (and (< v t) ..)
      (< (+ v ..) t)))

  

  (for t (prove < (+ (range t) ..) t)
    (implies (prove < (+ t ..) t)
      (< (+ (range t) ..) t)))

  (for t (prove < (+ )))


  (new (range integer) 5)
  (range 5 5)

  (new (range u8) 256)
  (range 256 256)



  (new (range u8)
    (+ (range 10 20)
       (range 30 40)))
  -->

  (for v (prove < (+ v ..) u8)
    ]))

(not any)
(lift (not (lower any)))
(lift (not (lower (lift true))))
(lift (not true))
(lift false)
nothing

(for v (new any v) -> (: v any))
(for v (new nothing v) -> nothing)
(for v t (new (not t) v) -> (implies (new t v) (: v t)))


(boolean -> boolean)

(for t (<= t any) -> (not (= t any)))
(for b (: b boolean) -> (or (= b true) (= b false)))


(: true boolean)
(or (= true true) (= true false))



((<= boolean any) -> any)

(for t (not t) -> (not t))
(for t (or t ..) -> (or t ..))
(for t (and t ..) -> (and t ..))
(for p c (implies p c) -> (implies p c))

(for v (new (or) v) -> none)
(for v t o
  (new (or t o ..) v)
  ->
  (implies (implies (: v t)
                    (: v t))
           (new (or o ..)
                v)))










(for t u o v
  (prove (new (or t o ..) v) u)
  ->
  (implies (implies (<= u t)
                    (: v u))
           (: (new (or o ..) v) u)))

(prove (new (or boolean integer)
         (+ 2 3))
       u8)
(implies (implies (<= u8 boolean)
                  (: (+ 2 3) u8))
         (: (new (or integer)
                 (+ 2 3))
            u8))
(implies (implies false
                  (: (+ 2 3) u8))
         (: (new (or integer)
                 (+ 2 3))
            u8))
(implies any
         (: (new (or integer)
                 (+ 2 3))
            u8))
(: (new (or integer)
        (+ 2 3))
   u8)
(implies (implies (<= u8 integer)
                  (: (+ 2 3) u8))
         (: (new (or) (+ 2 3)) u8))
(implies (implies any
                  (: (+ 2 3) u8))
         (: (new (or) (+ 2 3)) u8))
(implies (: (+ 2 3) u8)
         (: (new (or) (+ 2 3)) u8))
(implies (: (+ 2 3) u8)
         (: (new (or) (+ 2 3)) u8))




(new (or (not defined) defined) x)
(implies (implies (: x (not defined))
                  (: x (not defined)))
         (implies (: x defined)
                  (: x defined)))


(for v
  (new (or (not defined) defined) v)
  ->
  (seq v
    (not (: v defined))
    (: v defined)))


(for b (proof b) -> (proof b))
(for p (not p) -> (not p))
(for p (or p ..) -> (or p ..))
(for p (and p ..) -> (and p ..))
(for p c (implies p c) -> (implies p c))


(for t (defined t) -> (or t (not t) undefined))

(new (or boolean (not boolean) undefined)
     (and true false))
(proof (is (and true false) boolean))


(for v (is v defined) -> (seq v true false))

(new (provably boolean) (and true true))
(proof (is (and true true) boolean))

(new (provably boolean) (and false true))
(proof (is (and false true) boolean))

(new (provably integer) (+ -10 10))
(proof (is (+ -10 10) integer))

(new (proovably boolean) (+ -10 10))
(proof (not (is (+ -10 10) boolean)))

(new (provably boolean) (and or true))
(proof (not (is or defined)))

;;;;

(for b (proof b) -> (proof b))

(new (proof boolean) (and true true))
(proof (is (and true true) boolean))

(new (proof boolean) (and false true))
(proof (is (and false true) boolean))

(new (proof integer) (= -10 10))
(proof (not (= -10 10)))

(new (proof boolean) (and or true))
(proof (and ()))

;;; controversial

  (for b   (is b true)          -> b)
  (for b   (is b false)         -> (not b))
  (for b   (not (is b true))    -> (is false b))

  (for b   (new true b)         -> (is true b))
  (for b   (new false b)        -> (is false b))

;;;

(for k (ok k) -> (ok k))
(for e (err e) -> (err e))

(new (result boolean) (and true true))
(ok (and true true))

(new (result boolean) (and true false))
(ok (and true false))

(new (result boolean) (and or true))
(err (not (is or defined)))

(new (result boolean) (and true (new (result boolean) false)))
(err (and (not (is #0=(new (result boolean) false)
                   boolean))
          (is #0# (result boolean))))

;;; scratch


(for j (correct j) -> (correct j))
(for j (wrong j) -> (wrong j))

(for t v (new (correct t) v) -> (seq b (is v t)
                                       (correct v)
                                       (wrong b)))



(new boolean (and true true))
(correct (is (and true true) boolean))

(new boolean (and and true))
(wrong (not (and (is and defined)
                 (is and boolean))))

(new boolean (new boolean (and true true)))
(wrong (and (wrong (is (new boolean (and true true))
                       boolean)
            (is (new boolean (and true true))
                (proof boolean)))))

(undefined and)

(new boolean (new boolean (and true true)))
(wrong )

(new u8 100)
(correct 

(new (correct boolean) (and true (and and)))
; bad:  (wrong (is (and true (and and)) boolean))
; good: (wrong (is (and and) boolean))

(new (correct boolean) (and and))
(seq #0=(is #1=(and and) boolean) (correct #1#) (wrong #0#))
(wrong (is (and and) boolean))

(new (correct boolean) (and true false))
(seq (is #0=(and true false) boolean) (correct #0#) (wrong #0#))
(seq (is #0=false boolean) (correct #0#) (wrong #0#))
(seq true (correct #0=false) (wrong #0#))
(correct false)

(new (wrong boolean) (and and))
(correct (wrong (and and)))

(new (correct boolean) (and true false))
(correct false)

(new (correct boolean) (and true true))
(correct true)
;;;; scratch

(for j (correct j) -> (correct j))
(for j (wrong j) -> (wrong j))

(for j (not (correct j)) -> (wrong j))
(for j (not (wrong j)) -> (correct j))

(for j k (is j (the correct k)) -> (seq j ())

(for j (is j correct) -> (seq j (correct j) (wrong j)))
(for j (is j wrong) -)

(new boolean (and true true))
(ok (new boolean (and true true)))

(new )


(new (correct false) (and true true))

(is (and true true) the (correct false))




(is (and true true) (the correct false))
false

(is (and true false) (the correct true))
false


(is (and true true) boolean)
(correct true)

(is (and false true) boolean)
(correct false)

(is (not wrong) correct)
(correct correct)

(is wrong (and true wrong))
(correct wrong)

(is (and true true) correct)
(wrong (is (and true true) correct))

(is correct correct)
(wrong (is correct correct))


;; ???

(is wrong wrong)
(wrong (is wrong wrong))

; language 1a1

  (correct -> true)
  (wrong -> false)

  (boolean -> correct)


;;;;

(main : correct = (not wrong))
(correct correct)

(main : correct = (and true true))
(wrong (is correct correct))

(main : wrong = (and true wrong))
(correct wrong)

;;;;;;;;

(for m p r v o
  (begin (is m correct) (for v .. p -> r) o ..) -> )


;;;(for v p r b (let (for v .. p -> r) .. b) -> `(begin (for ,(v ..) ,p -> r) ..))




; non-negative integers

  (0 -> correct)
  (for n (next n) -> n)
  ; syntactic sugar by the compiler:
  ;   1 -> (next 0)
  ;   2 -> (next (next 0))
  ;   etc.

  (for z (+ 0 z ..) (+ z ..))
  (for x y (+ (next x) y ..) -> (next (+ y ..)))

  (is (and true boolean) correct)
  (is (and true boolean) true)
  (and true boolean)
  boolean
  correct
  true

; 

  (correct -> correct)
  (wrong -> wrong)

  ((not correct) -> wrong)
  ((not wrong) -> correct)

  ((and) -> correct)
  (all j (and wrong j ..) -> wrong)
  (all j (and correct j ..) -> (and j ..))

  ((or) -> wrong)
  (all j (or correct j ..) -> correct)
  (all j (or wrong j ..) -> (or j ..))

  (for p c (implies p c) -> (or (not p) c))

  
;

  (is (and true true) (type boolean))
  (is (and true true) correct)
  (is (and true true) true)
  (is (and true) true)
  (is (and) true)
  (is true true)
  true


  (is (and true true) (type boolean))
  (is (and true true) correct)

  ((all) -> true)
  (for p (all correct p ..) -> ())

  ((or) -> correct)
  (for t (or (not correct) t ..) -> (not correct))
  (for t (or correct t ..) -> (or t ..))

  (implies (is type type) type))
  (or (not (is type type)) type)
  (or (not false) type)
  (or true type)
  (not type)

  (implies (is boolean type) boolean)
  (or (not (is boolean type)) boolean)
  (or (not true) boolean)
  (or false boolean)
  boolean


  (is boolean type) -> true
  (is type type) -> false
  (for b (new type b) -> (implies (is b type) b))

  (new type boolean)
  (or (not (is boolean type)) boolean)
  (or (not true) boolean)
  (or false boolean)
  boolean

  (new type type)
  (implies (is type type) type)
  (or (not (is type type)) type)
  (or (not false) type)
  (or true type)
  true


  (for v t (is v t) -> (is v t))
  (for v t (is-not v t) -> (is-not v t))

  (type -> type)

  (For v t (def v t) -> ((the t v) -> (is v t)))

  (def boolean type)
  (def (not (is b boolean))
    (the boolean (not b)))

  ; ((the type boolean) -> (boolean is type))

  (true := boolean)
  (false := boolean)

  (not (b is boolean) := ((not b) is boolean))
  ; ((the boolean (not b)) -> (seq (the boolean b)
  ;                                ) (implies (defined (the boolean b))
  ;                                    (the boolean (not b))))
  ; (the boolean (not true))
  ; (implies (defined (the boolean true))
  ;          (the boolean (not true)))
  ; (implies (defined (true is boolean))
  ;          ((not true) is boolean))
  ; ((not true) is boolean)
  ; (false is boolean)
  
  ; -->
  ;  true -> boolean

  For v (~@ the boolean v) -> (implies )

  For v t (~@ v : t) -> (~@ v -> t)

  boolean : type

  true : boolean
  false : boolean


  (the boolean true)
  true :2 boolean

  (the boolean (not true))
  false :2 boolean



  (For b )



  For t v (~@ new t v) -> (~@ v : t)

  (not true) : boolean
  


  For f v r .

  not boolean : boolean
  not -> (For a r (implies (and (= r boolean)
                                (= a boolean))
                           (not a)))

  and boolean .. : boolean
  or boolean .. : boolean
  implies boolean boolean : boolean

; end


  For f at rt
  (f : at .. -> rt)
  ->
  (For rrt
   (implies (and (= rt rrt)
                 (a : t) ..)
            (f )
          

  (not : boolean -> boolean)
  (For rrt a
   (not )

  type -> type

  boolean : type

  true : boolean
  false : boolean

  not : boolean -> boolean
  or : boolean .. -> boolean
  and : boolean .. -> boolean
  implies : boolean boolean -> boolean

; scratch




  (all (f a a-t r-t)
    ((f (a : a-t) ..) : r-t)
    ->
    (all (requested-r-t)
      ((f a ..) : requested-r-t)
      ->
      (implies (and (= requested-r-t r-t)
                       (a : a-t) ...)
               (f a ..))))

  ((not (b : boolean) ..) : boolean)
  ->
  (all (requested-r-t)
    ((not b ..) : requested-r-t)
    ->
    (implies (and (= requested-r-t boolean)
                  (b : boolean))
             (not b ..)))




  boolean -> boolean

  (true : boolean) -> true
  (false : boolean) -> false







  (apply (all (f a a-t requested-r-t)
           ((f (a : a-t) ..) : requested-r-t)
           ->
           (implies (and (= requested-r-t r-t)
                         (a : a-t) ..)
                    (f a ..)))
         (all (f a a-t r-t)
           (fn (f (a : a-t) ..) -> r-t)))


  (all (f a a-t r-t)
    ((f (a : a-t)) : r-t)
    ->
    (all (requested-r-t)
      ((f a ..) : requested-r-t)
      ->
      (implies (and (= requested-r-t r-t)
                       (a : a-t) ...)
               (f a ..))))




  (all (l r o)
    (begin l : r o ..)
    ->
    (#%begin (: l r) (begin o ..)))

  (all (l r o)
    (begin l r o ..)
    ->
    (#%begin (: l r) (begin o ..)))

  (all (f a a-t r-t)
    (fn (f (a : a-t) ..) : r-t)
    ->
    (all (requested-r-t)
      ((f a ..) : requested-r-t)
      ->
      (implies (and (= requested-r-t r-t)
                       (a : a-t) ..)
               (f a ..))))

  type -> type

  boolean : type

  true : boolean
  false : boolean

  (not (b : boolean)) : boolean


  (fn (not (b : boolean)) -> boolean)
  (fn (and (b : boolean) ..) -> boolean)
  (fn (or (b : boolean) ..) -> boolean)
  (fn (implies (b1 : boolean) (b2 : boolean)) -> boolean)



  (fn (not (b : boolean)) -> boolean)
  ->
  (all (requested-return-type)
    ((not b) : requested-return-type)
    ->
    (implies (and (= requested-return-type boolean)
                  (b : boolean))
             (not b)))

  (all (f b t1 t2)
    (fn (f (~@ b : t1) ..) -> t2)
    ->
    (all (b1 t3)
      (: (f b1 ..) t3)
      ->
      (implies (and (= t3 t2)
                    (: b1 b) ..)
               (f b1 ..))))

  (fn (not (b : boolean)) -> boolean)

  (all (b t)
    (: (not b) t)
    ->
    (implies (and (= t boolean)
                  (: b boolean))
             (not b)))

  (all (b t)
    (: (and b ..) t)
    ->
    (implies (and (= t boolean)
                  (and (: b boolean) ..))
             (and b ..)))


(: $b boolean) -> (or (= $b true) (= $b false))


(all (b t)
  (: (not b) t))
->
(implies (and (= t boolean)
              (: b boolean))
         (not b))

(: (not $b) $t) -> (implies (and (= $t boolean)
                                 (: $b boolean))
                            (not $b))


(: (not 123) boolean)
->
(implies (and (= boolean boolean)
              (: 123 boolean))











(and) -> true
(and false $b ..) -> false
(and true $b ..) -> (and $b ..)
(: (and $b ..) $t) -> (implies (= $t boolean) (and $b ..))

(or) -> false
(or true $b ..) -> true
(or false $b ..) -> (or $b ..)
(: (or $b ..) $t) -> (implies (= $t boolean) (or $b ..))

(implies $x $y) -> (or (not $x) $y)
(: (implies $x $y) $t) -> (implies (= $t boolean) (implies $x $y))

(: (: $x $t1) $t2)
->
(implies (: $t1 $t2) (: $x $t2))



(: (not true) true)
->
(implies (= true boolean)
         (not true))
->
(or (not (= true boolean))
    (not true))
->




(: (not true) boolean)
->
(implies (= boolean boolean) (not true))
->
(or (not (= boolean boolean))
    (not true))
->
(or (not true)
    (not true))
->
(or false (not true))
->
(or (not true))
->
(or false)
->
true

; (: (: true boolean) type)
; ->
; (implies (: boolean type) (: true type))
; ->
; (or (not (: boolean type)) (: true type))
; ->
; (or (not true) (: true type))
; ->
; (or false (: true type))
; ->
; true
