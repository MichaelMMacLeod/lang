; language 1 (boolean values and boolean logical operations)

  (for true  -> true)
  (for false -> false)

  (for (is-false false) -> true)
  (for (is-false true)  -> false)

  ; I have deliberately not provided a definition of 'is-true'
  ; here. This is because if 'b' is either 'true' or 'false', then
  ; '(is-true b)' is equal to 'b'. Because it is clearer and faster to
  ; use 'b' instead of '(is-true b)', just use 'b'. If a definition of
  ; 'is-true' were to be provided, it would be this:
  ;
  ; (for (is-true true)  -> true)
  ; (for (is-true false) -> false)

  (for   (all-true)            -> true)
  (for b (all-true false b ..) -> false)
  (for b (all-true true  b ..) -> (all-true b ..))

  (for   (all-false)            -> true)
  (for b (all-false true  b ..) -> false)
  (for b (all-false false b ..) -> (all-false b ..))

  (for   (at-least-one-true)            -> false)
  (for b (at-least-one-true true  b ..) -> true)
  (for b (at-least-one-true false b ..) -> (at-least-one-true b ..))

  (for   (at-least-one-false)            -> false)
  (for b (at-least-one-false false b ..) -> true)
  (for b (at-least-one-false true  b ..) -> (at-least-one-false b ..))

  (for   (exactly-one-true)                  -> false)
  (for   (exactly-one-true false)            -> false)
  (for   (exactly-one-true true)             -> true)
  (for b (exactly-one-true true  true  b ..) -> false)
  (for b (exactly-one-true false false b ..) -> (exactly-one-true      b ..))
  (for b (exactly-one-true true  false b ..) -> (exactly-one-true true b ..))
  (for b (exactly-one-true false true  b ..) -> (exactly-one-true true b ..))

  (for   (exactly-one-false)                  -> false)
  (for   (exactly-one-false true)             -> false)
  (for   (exactly-one-false false)            -> true)
  (for b (exactly-one-false false false b ..) -> false)
  (for b (exactly-one-false true  true  b ..) -> (exactly-one-false       b ..))
  (for b (exactly-one-false false true  b ..) -> (exactly-one-false false b ..))
  (for b (exactly-one-false true  false b ..) -> (exactly-one-false false b ..))

  (for t   (if true  then t)        -> t)
  (for t   (if false then t)        -> true)
  (for t e (if true  then t else e) -> t)
  (for t e (if false then t else e) -> e)

  ; I will now claim that it is possible to define only 'not-all-true'
  ; and then define every single other operation above in terms of it,
  ; although I have not provided a proof of this clame here; my
  ; apologies for that. Other people have proved that there are also
  ; other operations which have this property, a property called
  ; 'functional completeness'. To improve readability and performance,
  ; I have implemented every operation in the simplest manner I was
  ; able to, without building upon other operations. These are
  ; clarity/performance critical rules; it is necessary for them to be
  ; easy to understand and for them to run quickly; if you are able to
  ; make improvements to either aspect, please do so!

  (for (equal) -> true)
  (for t (equal t) -> true)
  (for t0 t1 t
    (equal t0 t1 t ..) ->
    (sequence (= t0 t1) (equal t1 t ..) false))

; probable none-sense follows


  ; boolean type

    (for boolean -> boolean)
    
    (for (< true  boolean) -> true)
    (for (< false boolean) -> true)

    (for b
      (< (all-true b ..) boolean) ->
      (all-true (< b boolean) ..))

  ; term type

    (for t (term t) -> (term t))

    (for v t (< v (term t)) ->
      (sequence (< v t) (< v t) false))

    (< true (term boolean))
    -->
    (sequence (< true boolean)
              (< true boolean)
              false)
    -->
    (sequence #0=true
              #0#
              false)
    -->
    true

    (< 0 (term boolean))
    -->
    (sequence (< 0 boolean)
      (< 0 boolean)
      false)
    -->
    false

  (proof < true boolean)
  (proof all-false )

  (new boolean true)
  -->
  (proof (< true boolean))

  (new boolean "Hello, world!")
  -->
  (proof (< "Hello, world!" boolean))

  (new string "Hello, world!")
  -->
  (proof (all-false (< "Hello, world!" string)))

  (new boolean (all-true true false))
  -->
  (proof (< (all-true true false) boolean))

  (new boolean (all-true true "Hello, world!"))
  -->
  (proof (all-false (< )))

  (for (true (< true boolean)) -> (true (< true boolean)))
  (for (true (< false boolean)) -> (true (< false boolean)))

  (for t (?check (< t boolean)) ->
    (if (at-least-one-true (equal t true)
                           (equal t false))
      then (true (< t boolean))))



  It is all well and good that we can now compute if some terms are
  'all-true' or 'all-false', or check if exactly one of them is true
  and so on. But there is a real problem that arises when we write
  something like this:

    (all-true true SURPRISE)

  If we were to write this the system would halt because it would be
  unable to rewrite the term (all-true SURPRISE), as there are no
  rules for doing so.

  What we want is to be able to ask the system if, when reduced, a
  certain term will reduce to some other terms, and not get 'stuck'
  like this. In this example, we would want to ask if '(all-true true
  SURPRISE)' would reduce to either 'true' or 'false'. The answer we
  want from the system would be one of the following: (1) a proof that
  the term in question reduces to 'true' or 'false'; (2) a proof that
  the term cannot be reduced to 'true' or 'false', and a good
  explanation of why it cannot.

  For example, if we asked the system if '(all-true true (all-false
  yikes true))' reduced to 'true' or 'false', we would like to get
  back a proof that it can't be, because 'yikes' is not 'true' or
  'false'.

  After we get such a proof, it needs to be possible to extract the
  term inside of a successful proof an evaluate it.

  There are some subtleties to this that I want to point out. First,
  if we ask the system to prove that '(all-true false SURPRISE)' is a
  boolean, I think I want it to say 'no', even though, technically,
  when reduced, '(all-true false SURPRISE)' will be 'false', because
  as soon as it sees the first 'false' it reduces to 'false' and
  doesn't look at its other arguments. This is to say that for a proof
  to work, it needs to be the case that all the arguments to
  'all-true' are actually terms.

  First, to represent a type being either 'true' or 'false', we can
  call that '(+ true false)', or 'boolean'. Second, it should be the
  case that anything that is reducible to a fixed point should have
  type 'top', and anything that isn't should have type 'bot'. 

  (for in out
    (worker in out) ->
    (worker in out))

  (for in out
    (< (worker in out) term) ->
    (if (all-true (< in term)
                  (< out term))
      then (term (worker in out))))



  (for k (ok k) -> (ok k))
  (for e (err e) -> (err e))

  (for k1 k2 (if (ok k1) then (ok k2)) -> (ok k2))
  (for e v   (if (err e) then v)       -> (err e))

  (for (all-ok) -> (ok true))
  (for (all-ok (ok k) o ..) -> (all-ok o ..))
  (for (all-ok (err e) o ..) -> (err e))

  (for (new true true) -> (ok true))
  (for (new false false) -> (ok false))
  (for t
    (new boolean t) ->
    (if (at-least-one-ok (new true t)
                         (new false t))
      then (ok (< t boolean))))

  (for v t
    (proof (< v t)) ->
    (proof (< v t)))
  (for v t
    (proof (all-false (< v t) ..)) ->
    (proof (all-false (< v t) ..)))

  (for (is-provable (< true boolean)) -> (proof (< true boolean)))
  (for (is-provable (< false boolean)) -> (proof (< false boolean)))

  (for v t
    (if (proof (< v t))
      then ))

  (for (is-provable (< t boolean)) ->
    (if (at-least-one-provable (= t true) (= t false))
      then (proof (< t boolean))))

  (for t
    (? (< t boolean)) ->
    (?at-least-one-true (= t true)
                        (= t false)))

  (for t
    (prove (< (all-true t ..) boolean)) ->
    (if (prove )
      then (proof (< t boolean))))

  (prove (< (all-true true false) boolean))
  -->
  (proof (< (all-true true false) boolean))

  (prove (< (all-true true Surprise) boolean))
  -->
  (proof (all-false (< (all-true true Surprise) boolean)
                    (< Surprise boolean)
                    (< Surprise term)))

  (proof term has type)
  (proof (< V T))

  (proof term does-not-have type because reason)
  (proof (all-true (is-false (< V T))
                   (is-false (< ))))

  (for c (true  c) -> (true  c))
  (for c (false c) -> (false c))

  (for v c (< v (true c)) ->
    )

  (for c (is-false (true  c)) -> (false c))
  (for c (is-false (false c)) -> (true  c))

  (for t (proof t) -> (proof t))

  (for (< consistent (proof t)) -> true)
  (for t1 t2
    (< (inconsistent (< v t1))
       (proof t2)) ->
    (equal t1 t2))


  (proof (< (all-true true false) boolean))
  


  (for v t
    (< (all-true v ..) t)
    (all-true (< v t) ..))
  (for v t
    (< (all-false v ..) t)
    (all-true (< v t) ..))

  (< (all-true true false) (proof boolean))
  -->
  (all-true (< true (proof boolean))
            (< false (proof boolean)))
  -->
  (all-true consistent consistent)
  -->
  consistent

  (< (all-true true false) boolean)
  -->
  (all-true (< true boolean) (< false boolean))
  -->
  true


  Is the following less than 'boolean'?

    (all-true true false Surprise!)

  No, because 'Surprise!' is not less than boolean.


  (for t (< t boolean)
    (if (at-least-one-true (equal t true)
                           (equal t false))
      then consistent
      else (inconsistent (< t boolean))))

  (for (< (all-true) proof) -> consistent)
  (for p
    (< (all-true consistent p ..) proof) ->
    (< (all-true p ..) proof))
  (for p
    (< (all-true (inconsistent v) p ..) proof) ->
    (inconsistent v))


  (for (< true proof) -> consistent)

  (for (prove (< true boolean)) -> consistent)
  (for (prove (< false boolean)) -> consistent)

  (for b
    (prove (< (all-true b ..) boolean)) ->
    (< (all-true (prove (< b boolean)) ..) proof))

  (for
    (prove (< v t)) ->
    (if (< v t)
      then consistent
      else (inconsistent (< v t))))

  (prove (< (all-true true Surprise) boolean))
  -->
  (if (< (all-true true Surprise) boolean)
    then consistent
    else (inconsistent (< (all-true true Surprise) boolean)))

  (for b
    (< (all-true b ..) boolean) ->
    (all-true (< b boolean) ..))
  (for (< true boolean) -> true)
  (for (< false boolean) -> true)

  (< (all-true true false) boolean)
  -->
  (all-true (< true boolean) (< false boolean))
  -->
  (all-true true true)
  -->
  true

  (for l u
    (+ (range l u) ..) ->
    (range (+ l ..) (+ u ..)))


  (for l u t
    (< (range l u) (range t)) ->
    (all-true (< l t)
              (< u t)
              (<= l u)))


  (for v l u
    (< (+ v ..) (range l u)) ->
    (< (+ (< v ))))



  (for (< (< v t) proof)
    (if (< v t)
      then (proof (< v t))
      else (proof (is-false (< v t)))))

  (for
    (< (< (range l u) (range t)) proof) ->
    (if (< (range l u) (range t))
      then (proof (< (range l u) (range t)))
      else (proof (is-false (< (range l u) (range t))))))



  (is-false )

  (for (proof true) -> true)
  (for (proof false) -> false)
  (for true -> (proof true))
  (for false -> (proof false))


  (for l r
    (< (< (= l r) true) proof)
    )






  (for (prove true is boolean) -> (proof true is boolean))
  (for (prove false is boolean) -> (proof false is boolean))

  (for x
    (prove boolean (all-true x ..)) ->
    (prove boolean x ..))







  (for x
    (< (all-true x ..) boolean) ->
    (all-true (< x term) .. (< x boolean) ..))

  (for t v
    (new t v) ->
    (if (< v t)
      then (proof (< v t))
      else (proof (is-false (< v t)))))




  (for consistent -> consistent)
  (for contradictory -> contradictory)

  (for (the bool consistent) -> true)
  (for (the bool contradictory) -> false)

  (for (the result true) -> consistent)
  (for (the result false) -> inconsistent)

  (for f
    (implement result f) ->
    (for p (the result (f (the bool p) ..))))

  (for defined -> defined)
  (for undefined -> undefined)

  (for v
    (lower-to-false) ->)



  (for t
    (< t term) ->
    (sequence (= t term) term undefined-term))
  (for t0 t1 t
    (< t0 t1 t .. term) ->
    (all-true (< t0 t1) (< t1 t .. term)))




; language 3 (boolean)

  (for boolean -> boolean)

  (for t (< t boolean) ->
    (if (< t term)
      then (at-least-one-true (equal t true)
                              (equal t false))))

  (for   (< false      boolean) -> true)
  (for   (< true       boolean) -> true)
  (for b (< false b .. boolean) -> (< b .. boolean))
  (for b (< true  b .. boolean) -> (< b .. boolean))

; language 4 (proof, new, the)

  (for t (proof t) -> (proof t))

  (for t v (new t v) ->
    (if (< v t)
      then (proof (< v t))
      else (proof (is-false (< v t)))))

  (for t1 t2 v
    (the t1 (proof (< v t2))) ->
    (sequence (= t1 t2) v))



 (the boolean
   (new boolean (all-true true false)))
 ->
 (the boolean
   (if #0=(< (all-true true false) boolean)
     then (proof #0#)
     else (proof (is-false #0#))))
 ->
 (the boolean
   (if #0=(< (all-true false) boolean)
     then (proof #0#)
     else (proof (is-false #0#))))
 ->
 (the boolean
   (if #0=(< false boolean)
     then (proof #0#)
     else (proof (is-false #0#))))
 ->
 (the boolean
   (if #0=true
     then (proof #0#)
     else (proof (is-false #0#))))
 ->
 (the boolean (proof true))
   (if #0=true
     then (proof #0#)
     else (proof (is-false #0#))))



 (for (< true boolean) -> true)
 (for (< false boolean) -> true)




 (new integer false) -> 0
 (new integer true) -> 1

 (new boolean 0) -> false
 (new boolean 1) -> true

 

 (for array = glue.builtin.array)
 (for 

 (for t         (array t ..) =
   (glue.builtin.array t ..))

 (for f t             (apply f (array t ..)) =
   (glue.builtin.array.apply f (array t ..)))

 (for f t )

 (for f t             (map f (array t ..)) =
   (glue.builtin.array.map f (array t ..))


 (def t (list t ..))
 (def )

 (unsafe for f t
   (apply f (list t ..)))

 (for f t
   (apply f (list t ..)) ->
            (f    t ..))

 (for f t
   (map f (list    t  ..)) ->
          (list (f t) ..))

 (for t (some t) = (list t))
 (for    none    = (list))

 (for k (ok k)   = (list (some k) none))
 (for e (err e)  = (list none (err e)))









; language 1.25 (boolean ordering operations)

  ; It is not uncommon to think of 'true' being 'one' and 'false'
  ; being 'zero'. This is often defined to be the case in C/C++, for
  ; example---although the opposite is also often the case, e.g., bash
  ; return codes, where 'zero' means 'success' or 'true' and 'one' (or
  ; any number at least 'one') means 'failure' or 'false'. Ultimately
  ; it is of no importance which way 'true' and 'false' are defined so
  ; long as it is not ambiguous which way they are defined. We take
  ; the choice of 'true' being 'one' and 'false' being 'zero' here
  ; because in other places when we lift '<' and interpret its
  ; operands as types, it is more common to think of '(< T1 T2)' as
  ; meaning 'T1 is a strict subtype of T2' and not 'T2 is a strict
  ; subtype of T1'. The conversion to 'one' and 'zero' is not given
  ; here, but ordering operators will be defined in its place.

        ((<)                      -> true)
        ((< true)                 -> true)
        ((< false)                -> true)
  (for b (< true true b ..)       -> false)
  (for b (< true false b ..)      -> false)
  (for b (< false false b ..)     -> false)
  (for b (< false true b ..)      -> (< true b ..))

        ((>)                      -> true)
        ((> true)                 -> true)
        ((< false)                -> true)
  (for b (> false true b ..)      -> false)
  (for b (> true true b ..)       -> false)
  (for b (> false false b ..)     -> false)
  (for b (> true false b ..)      -> (> true b ..))

        ((<=)                     -> true)
        ((<= true)                -> true)
        ((<= false)               -> true)
  (for b (<= true false b ..)     -> false)
  (for b (<= true true)           -> (<= true b ..))
  (for b (<= false true b ..)     -> (<= true b ..))
  (for b (<= false false)         -> (<= false b ..))
                                  
        ((>=)                     -> true)
        ((>= true)                -> true)
        ((>= false)               -> true)
  (for b (>= false true b ..)     -> false)
  (for b (>= true true b ..)      -> (>= true b ..))
  (for b (>= true false b ..)     -> (>= true b ..))
  (for b (>= false false b ..)    -> (>= false b ..))

; language 1.4 (aliases for ordering operations)

  (strictly-decreasing     -> >)
  (strictly-increasing     -> <)
  (non-strictly-decreasing -> >=)
  (non-strictly-increasing -> <=)

; language 1.5 (default definitions for ordering operations)

  ; Defines '>=', '<=', and '>' in terms of '<' (and some boolean
  ; operations) to aid in the implementation of custom orderings.

  (for x (>= x ..) -> (not (< x ..)))
  (for x (<= x ..) -> (or (< x ..) (= x ..)))
  (for x (> x ..)  -> (nor (< x ..) (= x ..)))

; language 2 (top and bottom types and type operations) [imports 1, 1.5]

  (any -> (lift true))
  (nothing -> (lift false))

  ((lift true) -> (lift true))
  ((lift false) -> (lift false))

  (for t (lower (lift t)) -> t)

  (for op (lift-op op ..) ->
    (begin (for p (op p ..) ->
             (op (lower p) ..))
           ..))

  (lift-op and not nand or xor implies =)

  (for t (< t nothing) -> false)
  (for t (< t any) -> (not (>= t any)))

  (for v t (the (<= v t)) -> (the (<= t v)))
  (for v t (the t v) -> (implies (<= v t) (the (<= t v))))

  (for b (< b)                    -> true)
  (for b (< any nothing b ..)     -> false)
  (for b (< nothing nothing b ..) -> false)
  (for b (< any any b ..)         -> false)
  (for b (< nothing any b ..)     -> (< any b ..))

; language 22 (well-typed and ill-typed types and operations)

  (well-typed -> (lift any))
  (ill-typed -> (lift nothing))

  ((lift any) -> (lift any))
  ((lift nothing) -> (lift nothing))

  (for t (lower2 (lift (lift t))) -> t)

  (for op (lift2-op op ..) ->
    (begin (for p (op p ..)
             (op (lower2 p) ..)
             ..)))

  (lift2-op and not nand or xor implies =)

  (for t (< t well-typed) -> (not (>= t well-typed)))

; language 3 (the type boolean) [imports 2]

  (boolean -> boolean)

  (for t (< t boolean) -> (or (= t true) (= t false)))

  (for b (< boolean any b ..) -> (< any b ..))
  (for b (< nothing boolean b ..) -> (< b ..))

  (for op (annotate-with-types t op ..) ->
    (begin
      (for v (prove < (op v ..) t)
        (implies (and (prove < v t) ..)
          (< (op v ..) t)))))

  (annotate-with-types boolean
    and nor nand or xor implies < > <= >= =)

  (for v (prove < (and v ..) boolean)
    (implies (and (prove < v boolean) ..)
      (< (and v ..) boolean)))

  (prove <= undefined-lol any)
  (impl prove <= undefined-lol any)
  (> undefined-lol any) ; e.g., this is not a defined term in our language

  (for t (impl <= t any) ->
    (let (i -> (<= t any))
      (catch ((irreducible i) -> (> t any))
        (<= t any))))


  ; (new delimiter <handler>) -> <delimiter>
  ; (<delimiter> <body>) -> <body-delimited>

  Evaluating '~' terms eagerly in rule terms


    (for contains~terms
      (remove-all~terms contains~terms) ->
      (let (all~terms ->
             (new environment
               (for m (~ m ..) ->
                 (raise (~ m ..)))))
        (catch (for m (~ m ..) -> (m ..))
               (for no~terms env
                 (irreducible no~terms env) ->
                 no~terms)
          (with-environment (and this-environment all~terms)
            contains~terms))))

    (remove-all~terms (~ and true false))
    -->
    (let (all~terms ->
           (new environment
             (for m (~ m ..) ->
               (raise (~ m ..)))))
      (catch (for m (~ m ..) -> (m ..))
             (for no~terms env
               (irreducible no~terms env) ->
               no~terms)
        (with-environment (and this-environment all~terms)
          (~ and true false))))
    -->
    (catch (for m (~ m ..) -> (m ..))
           (for no~terms env
             (irreducible no~terms env) ->
             no~terms)
      (with-environment (and this-environment all~terms)
        (~ and true false)))
    -->
    

    (for v p r (dyn v .. p -> r) ->
      (remove-all~terms
        (for v .. p -> r)))


    (for contains~terms (remove-all~terms contains~terms) ->
      (let (all~terms -> (new environment (val m (~ m ..))))
        (catch (for m env (irreducible m env) -> m)
          (with-environment (and current-environment all~terms)
            contains~terms))))

    (for m
      (for~parser (~incomplete m)) ->
      )

    (for m
      (for-tilde-parser (~literal m) ->
        (~literal m)))
    (for m
      (for-tilde-parser (~ m ..)) ->
      (seq (m ..)
           (~literal (m ..))))
    

    (for v p r
      (dyn v .. p -> r) ->
      )
    

  Fixed points

    (for v f (val v .. f) -> (for v .. f -> f))

  Dynamic rules

    (for v p p-f p-i
           r r-f r-i
      (dyn v .. (~ val p p-f p-i) -> (~val r r-f r-i))
      (val p )
    (for v p r
      (dyn v .. (~val p) -> (~val r)) ->
      (val p (val r (for v .. p -> r))))
    (for v p r
      (dyn v .. p -> (val r)) ->
      (seq r (for v .. p -> r)))
    (for v p r
      (dyn v .. (val p) -> r) ->
      (seq p (for v .. p -> r)))

  Rules for declaring fixed-points

    (for v pr
      (for. v .. pr .) ->
      (for v .. pr -> pr))
    (for v p r
      (for. v .. p -> r) ->
      (for v .. p -> r))

  Rules for throwing and catching exceptions

    (for e (exception e) -> (exception e))
    (sequence (new delimiter)
      (for catch-delimiter -> (new delimiter)))
    (for e (raise e) -> (abort catch-delimiter (exception e)))
    (for v (try v) ->
      (delimit catch-delimiter
               (for e (exception e) -> (err e))
        (ok v)))
    (for c v (catch c .. v) ->
      (delimit catch-delimiter
               (for e (exception e) ->
                 (let c .. e))
               v))


    (catch (for A -> 10)
      (catch (for A -> 100)
        (raise A)))
    -->
    (delimit catch-delimiter
             (for e (exception e) ->
               (let (A -> 10)
                 e))
      (catch (for A -> 100)
        (raise A)))
    -->
    (catch (for A -> 100)
      (raise A))
    -->
    (delimit catch-delimiter)
              


    (catch (for A -> 10)
           (for B -> 100)
      (raise A))
    -->
    (delimit catch-delimiter
             (for e (exception e) ->
               (let (for A -> 10)
                    (for B -> 100)
                 e))
             (raise A))
    -->
    (delimit <delimiter>
             (for e (exception e) ->
               (let (for A -> 10)
                    (for B -> 100)
                 e))
             (raise A))
    -->
    (delimit <delimiter>
             <rule>
             (raise A))
    -->
    (raise A)
    -->
    (abort catch-delimiter (exception A))
    -->
    (abort <delimiter> (exception A))
    -->
    (let (for A -> 10)
         (for B -> 100)
      A)
    -->
    A
    -->
    10
    



    (sequence (new unique identifier)
      (for catch-delimiter -> (new unique identifier)))


    (for catcher body
      (catch catcher .. body) ->
      (delimit catch-delimiter))

    
    (sequence catch-delimiter
      (for catch-delimiter -> (new delimiter)))

    (sequence (new unique symbol)
      (let (dynamic -> (new unique symbol))
        (let (body -> dynamic)
          (sequence dynamic
            (let (dynamic -> A)
              body)))))
    -->
    (let (dynamic -> unique-symbol#12345)
      (let (body -> dynamic)
        (sequence dynamic
          (let (dynamic -> A)
            body))))
    -->
    (let (body -> dynamic)
      (sequence dynamic
        (let (dynamic -> A)
          body)))
    -->
    (sequence dynamic
      (let (dynamic -> A)
        body))
    -->
    (let (unique-symbol#12345 -> A)
      body)
    -->
    body
    -->
    dynamic
    -->
    unique-symbol#12345
    -->
    A


    (sequence catch-delimiter
      (let (catch-delimiter -> A)
        catch-delimiter))
    (for e (throw e) -> (abort catch-delimiter e))
    (for c b
      (catch c .. b) ->
      (sequence catch-delimiter
        (let (catch-delimiter ))))

    (seq (new delimiter)
      (for exception-delimiter (new delimiter)))
    (for e (throw e) ->
      (abort exception-delimiter e))
    (for catcher body
      (catch catcher .. body) ->
      (seq exception-delimiter
        (seq (new delimiter)
          (let (for exception-delimiter ->)))))

  Rules which eagerly reduce their patterns and results

    (for v p0 p1 p r0 r1 r
      (for~ v .. (~ p0 p1 p ..) -> (~ r0 r1 r ..)) ->
      (seq (p0 p1 p ..)
           (seq (r0 r1 r ..)
                (for. v .. (p0 p1 p ..) -> (r0 r1 r ..)))))
    (for v p r0 r1 r
      (for~ v .. (. p) -> (~ r0 r1 r ..)) ->
      (seq (r0 r1 r)
           (for v .. p -> (r0 r1 r ..))))
    (for v p r
      (for~ v .. (. p) -> (. r)) ->
      (for. v .. p -> r))
    (for v pr
      (for~ v .. pr .) ->
      (for. v .. pr .))

  Rules for throwing and catching exceptions

    (for~ e (uncaught-exception e) .)
    (for~ (. exception-delimiter) -> ())

  Throwing and catching exceptions: '(catch handler .. body)' and
  '(raise exception)'.

    (for. e (uncaught-exception e) .)
    (for. exception-delimiter -> ())



    

    (val e (uncaught-exception e))
    (dyn exception-delimiter -> (new continuation-delimiter))
    (dyn (val exception-delimiter) ->
      (new-continuation-delimiter
        (for (exception e) ->
          (uncaught-exception e))))
    (for e (raise e) ->
      (continuation-delimit exception-delimiter e))
    (for catcher body (catch c .. v) ->
      (let (dyn (~reduce exception-delimiter) ->
             (new delimiter
               (for (exception e) ->
                 (let c .. e))))
        body))



    (for c v (catch c .. v) ->
      (let (dyn e )))

  (for e (uncaught-exception e) .)

  

  (dyn current-exception-delimiter (~reduce (new unique symbol)))
  (dyn )




  (for exception-delimiter -> (~reduce (new unique term)))
  (for (~reduce exception-delimiter) ->
    )

  (for exception-delimiter -> dyn
    (new unique term))
  (dyn exception-handler ->
    (for e (exception e) ->
      (uncaught-exception e)))



  (for v d r (dyn v .. d r) -> (for v .. (#%reduce d) -> r))
  (for e (uncaught-exception e) .)
  (dyn exception-delimiter ->
    (for e (exception e) ->
      ))

  (for (#%reduce exception-delimiter) ->
    (for e (exception e) ->
      ()))


  (for (#%reduce-once exception-delimiter) ->
    (for e (exception e)
      (uncaught-exception e)))

  (#%reduce (+ 1 (* 2 3)))
  (#%incomplete (+ 1 (#%reduce (* 2 3))))
  (#%reduce (+ 1 6))
  7




  (+ 1 (* 2 3))
  (#%reduce (+ 1 (* 2 3)))
  ((#%reduce +) 1 (* 2 3))
  ((#%irreducible +) (#%reduce 1) (* 2 3))
  (#%reduce ((#%irreducible +) (#%done 1) (* 2 3)))
  ((#%irreducible +)
   (#%done 1)
   (#%reduce (* 2 3)))
  ((#%irreducible +)
   (#%done 1)
   ((#%reduce )))

  (reduce>>> reduce (+ 1 (* 2 3)))
  (>>> reducing (+ (#%reduce 1) (* 2 3)))
  (>>> reducing (+ (#%done 1) (#%reducing (* 2 3))))
  (#%reduce (+ (#%done 1) (* 2 3)))
  (+ (#%done 1)
     (* (#%reduce 2) 3))
  (#%reduce (+ 1 (* 2 3)))
  

  (dyn exception-delimiter ->
    (new delimiter
      (for e (exception e) ->
        ())))

  (for catcher body )

  (for catcher body (catch catcher .. body)
    (dynamic-let (exception-delimiter ->
                   (new delimiter
                     (for e (exception e)
                       (let catcher .. e))))
      (delimit body exception-delimiter)))

  (for e (raise e)
    (abort exception-delimiter e))


  (catch (A -> 100)
    (raise A))
  -->
  (let (d -> (new delimiter
               (for ))))


  (for abort-handler body (new continuation-delimiter abort-handler body) ->
    (dynamic-let (exception-delimiter -> (new continuation-delimiter))
      (continuation-delimit exception-delimiter)))

  (for catcher body (catch catcher .. body) ->
    (new continuation-delimiter
      (for e (exception e) ->
        (let catcher .. e))
      body))







  (current-exception-delimiter ->
    (new continuation-delimiter))

  (current-catcher ->
    (for e (exception e) ->
      (raise e)))

    (dynamic-let (current-exception-delimiter ->
                   (new delimiter))
      (new continuation-delimiter
        )
      (continuation-delimit current-exception-delimiter
        (for e (exception e)
          (let catcher .. e))
        ))


    (dynamic-let (current-catcher ->
                   (for e (exception e)
                     (let handler .. e)))
      body))

  (for e (raise e) ->
    (abort current-catcher))

  (catch (A -> 10)
         (B -> 100)
    (raise A))

  (for handler body (catch handler .. body) ->
    (dynamic-let (for exception (exception-handler exception) ->
                   (let handler .. exception))
      body))


  (<= surprise any)
  (let (i -> (<= #0=surprise any))
    (catch ((irreducible i) -> (> #0# any))
      (impl <= #0# any)))
  (let-handlers ((irreducible i) -> (> #0=surprise any))
    (impl <= #0# any))
  (impl <= surprise any)
  (continuation-abort current-catch
    (irreducible (impl <= surprise any)))
  (let ((irreducible #1=(impl <= #0=surprise any)) -> (> #0# any))
    (irreducible #1#))
  (irreducible (impl <= surprise any))
  (> surprise any)

  (for t (<= t any)
    (let (i (<= t any))
      (let-handlers (for (irreducible i) (> t any))
        (impl <= t any))))

  (<= Surprise! any)
  (let (i #0=(<= #1=Surprise! any))
    (let-handlers (for (irreducible i) (> #1# any))
      (impl <= #1# any )))



    (let-handlers (impl <= t any)
      (for term (irreducible term)
        ())
    (let-dynamic [current-abort-handler
                  (for term (irreducible term)
                    )]))

  (for op v t (prove op v t)
    (let [i -> (impl prove op v t)]
      (and (<= i any) i))

  (for op v t (prove op v t)
    (with-handlers [for v (irreducible v)]))

  (prove < (and true false) boolean)
  (let [i (impl prove < (and true false) boolean)]
    (and (<= i any) i))
  (and (<= i any) i)
  (and (<= #0=(impl prove < (and true false) boolean)
           any)
       #0#)
  (and ())


    (and (prove < (impl prove op v t) any)
         (prove ))
    (let [d ]
      (if d (the d) d)))

  (for v t (prove < (+ v ..) t)
    (implies (and (< v t) ..)
      (< (+ v ..) t)))

  

  (for t (prove < (+ (range t) ..) t)
    (implies (prove < (+ t ..) t)
      (< (+ (range t) ..) t)))

  (for t (prove < (+ )))


  (new (range integer) 5)
  (range 5 5)

  (new (range u8) 256)
  (range 256 256)



  (new (range u8)
    (+ (range 10 20)
       (range 30 40)))
  -->

  (for v (prove < (+ v ..) u8)
    ]))

(not any)
(lift (not (lower any)))
(lift (not (lower (lift true))))
(lift (not true))
(lift false)
nothing

(for v (new any v) -> (: v any))
(for v (new nothing v) -> nothing)
(for v t (new (not t) v) -> (implies (new t v) (: v t)))


(boolean -> boolean)

(for t (<= t any) -> (not (= t any)))
(for b (: b boolean) -> (or (= b true) (= b false)))


(: true boolean)
(or (= true true) (= true false))



((<= boolean any) -> any)

(for t (not t) -> (not t))
(for t (or t ..) -> (or t ..))
(for t (and t ..) -> (and t ..))
(for p c (implies p c) -> (implies p c))

(for v (new (or) v) -> none)
(for v t o
  (new (or t o ..) v)
  ->
  (implies (implies (: v t)
                    (: v t))
           (new (or o ..)
                v)))










(for t u o v
  (prove (new (or t o ..) v) u)
  ->
  (implies (implies (<= u t)
                    (: v u))
           (: (new (or o ..) v) u)))

(prove (new (or boolean integer)
         (+ 2 3))
       u8)
(implies (implies (<= u8 boolean)
                  (: (+ 2 3) u8))
         (: (new (or integer)
                 (+ 2 3))
            u8))
(implies (implies false
                  (: (+ 2 3) u8))
         (: (new (or integer)
                 (+ 2 3))
            u8))
(implies any
         (: (new (or integer)
                 (+ 2 3))
            u8))
(: (new (or integer)
        (+ 2 3))
   u8)
(implies (implies (<= u8 integer)
                  (: (+ 2 3) u8))
         (: (new (or) (+ 2 3)) u8))
(implies (implies any
                  (: (+ 2 3) u8))
         (: (new (or) (+ 2 3)) u8))
(implies (: (+ 2 3) u8)
         (: (new (or) (+ 2 3)) u8))
(implies (: (+ 2 3) u8)
         (: (new (or) (+ 2 3)) u8))




(new (or (not defined) defined) x)
(implies (implies (: x (not defined))
                  (: x (not defined)))
         (implies (: x defined)
                  (: x defined)))


(for v
  (new (or (not defined) defined) v)
  ->
  (seq v
    (not (: v defined))
    (: v defined)))


(for b (proof b) -> (proof b))
(for p (not p) -> (not p))
(for p (or p ..) -> (or p ..))
(for p (and p ..) -> (and p ..))
(for p c (implies p c) -> (implies p c))


(for t (defined t) -> (or t (not t) undefined))

(new (or boolean (not boolean) undefined)
     (and true false))
(proof (is (and true false) boolean))


(for v (is v defined) -> (seq v true false))

(new (provably boolean) (and true true))
(proof (is (and true true) boolean))

(new (provably boolean) (and false true))
(proof (is (and false true) boolean))

(new (provably integer) (+ -10 10))
(proof (is (+ -10 10) integer))

(new (proovably boolean) (+ -10 10))
(proof (not (is (+ -10 10) boolean)))

(new (provably boolean) (and or true))
(proof (not (is or defined)))

;;;;

(for b (proof b) -> (proof b))

(new (proof boolean) (and true true))
(proof (is (and true true) boolean))

(new (proof boolean) (and false true))
(proof (is (and false true) boolean))

(new (proof integer) (= -10 10))
(proof (not (= -10 10)))

(new (proof boolean) (and or true))
(proof (and ()))

;;; controversial

  (for b   (is b true)          -> b)
  (for b   (is b false)         -> (not b))
  (for b   (not (is b true))    -> (is false b))

  (for b   (new true b)         -> (is true b))
  (for b   (new false b)        -> (is false b))

;;;

(for k (ok k) -> (ok k))
(for e (err e) -> (err e))

(new (result boolean) (and true true))
(ok (and true true))

(new (result boolean) (and true false))
(ok (and true false))

(new (result boolean) (and or true))
(err (not (is or defined)))

(new (result boolean) (and true (new (result boolean) false)))
(err (and (not (is #0=(new (result boolean) false)
                   boolean))
          (is #0# (result boolean))))

;;; scratch


(for j (correct j) -> (correct j))
(for j (wrong j) -> (wrong j))

(for t v (new (correct t) v) -> (seq b (is v t)
                                       (correct v)
                                       (wrong b)))



(new boolean (and true true))
(correct (is (and true true) boolean))

(new boolean (and and true))
(wrong (not (and (is and defined)
                 (is and boolean))))

(new boolean (new boolean (and true true)))
(wrong (and (wrong (is (new boolean (and true true))
                       boolean)
            (is (new boolean (and true true))
                (proof boolean)))))

(undefined and)

(new boolean (new boolean (and true true)))
(wrong )

(new u8 100)
(correct 

(new (correct boolean) (and true (and and)))
; bad:  (wrong (is (and true (and and)) boolean))
; good: (wrong (is (and and) boolean))

(new (correct boolean) (and and))
(seq #0=(is #1=(and and) boolean) (correct #1#) (wrong #0#))
(wrong (is (and and) boolean))

(new (correct boolean) (and true false))
(seq (is #0=(and true false) boolean) (correct #0#) (wrong #0#))
(seq (is #0=false boolean) (correct #0#) (wrong #0#))
(seq true (correct #0=false) (wrong #0#))
(correct false)

(new (wrong boolean) (and and))
(correct (wrong (and and)))

(new (correct boolean) (and true false))
(correct false)

(new (correct boolean) (and true true))
(correct true)
;;;; scratch

(for j (correct j) -> (correct j))
(for j (wrong j) -> (wrong j))

(for j (not (correct j)) -> (wrong j))
(for j (not (wrong j)) -> (correct j))

(for j k (is j (the correct k)) -> (seq j ())

(for j (is j correct) -> (seq j (correct j) (wrong j)))
(for j (is j wrong) -)

(new boolean (and true true))
(ok (new boolean (and true true)))

(new )


(new (correct false) (and true true))

(is (and true true) the (correct false))




(is (and true true) (the correct false))
false

(is (and true false) (the correct true))
false


(is (and true true) boolean)
(correct true)

(is (and false true) boolean)
(correct false)

(is (not wrong) correct)
(correct correct)

(is wrong (and true wrong))
(correct wrong)

(is (and true true) correct)
(wrong (is (and true true) correct))

(is correct correct)
(wrong (is correct correct))


;; ???

(is wrong wrong)
(wrong (is wrong wrong))

; language 1a1

  (correct -> true)
  (wrong -> false)

  (boolean -> correct)


;;;;

(main : correct = (not wrong))
(correct correct)

(main : correct = (and true true))
(wrong (is correct correct))

(main : wrong = (and true wrong))
(correct wrong)

;;;;;;;;

(for m p r v o
  (begin (is m correct) (for v .. p -> r) o ..) -> )


;;;(for v p r b (let (for v .. p -> r) .. b) -> `(begin (for ,(v ..) ,p -> r) ..))




; non-negative integers

  (0 -> correct)
  (for n (next n) -> n)
  ; syntactic sugar by the compiler:
  ;   1 -> (next 0)
  ;   2 -> (next (next 0))
  ;   etc.

  (for z (+ 0 z ..) (+ z ..))
  (for x y (+ (next x) y ..) -> (next (+ y ..)))

  (is (and true boolean) correct)
  (is (and true boolean) true)
  (and true boolean)
  boolean
  correct
  true

; 

  (correct -> correct)
  (wrong -> wrong)

  ((not correct) -> wrong)
  ((not wrong) -> correct)

  ((and) -> correct)
  (all j (and wrong j ..) -> wrong)
  (all j (and correct j ..) -> (and j ..))

  ((or) -> wrong)
  (all j (or correct j ..) -> correct)
  (all j (or wrong j ..) -> (or j ..))

  (for p c (implies p c) -> (or (not p) c))

  
;

  (is (and true true) (type boolean))
  (is (and true true) correct)
  (is (and true true) true)
  (is (and true) true)
  (is (and) true)
  (is true true)
  true


  (is (and true true) (type boolean))
  (is (and true true) correct)

  ((all) -> true)
  (for p (all correct p ..) -> ())

  ((or) -> correct)
  (for t (or (not correct) t ..) -> (not correct))
  (for t (or correct t ..) -> (or t ..))

  (implies (is type type) type))
  (or (not (is type type)) type)
  (or (not false) type)
  (or true type)
  (not type)

  (implies (is boolean type) boolean)
  (or (not (is boolean type)) boolean)
  (or (not true) boolean)
  (or false boolean)
  boolean


  (is boolean type) -> true
  (is type type) -> false
  (for b (new type b) -> (implies (is b type) b))

  (new type boolean)
  (or (not (is boolean type)) boolean)
  (or (not true) boolean)
  (or false boolean)
  boolean

  (new type type)
  (implies (is type type) type)
  (or (not (is type type)) type)
  (or (not false) type)
  (or true type)
  true


  (for v t (is v t) -> (is v t))
  (for v t (is-not v t) -> (is-not v t))

  (type -> type)

  (For v t (def v t) -> ((the t v) -> (is v t)))

  (def boolean type)
  (def (not (is b boolean))
    (the boolean (not b)))

  ; ((the type boolean) -> (boolean is type))

  (true := boolean)
  (false := boolean)

  (not (b is boolean) := ((not b) is boolean))
  ; ((the boolean (not b)) -> (seq (the boolean b)
  ;                                ) (implies (defined (the boolean b))
  ;                                    (the boolean (not b))))
  ; (the boolean (not true))
  ; (implies (defined (the boolean true))
  ;          (the boolean (not true)))
  ; (implies (defined (true is boolean))
  ;          ((not true) is boolean))
  ; ((not true) is boolean)
  ; (false is boolean)
  
  ; -->
  ;  true -> boolean

  For v (~@ the boolean v) -> (implies )

  For v t (~@ v : t) -> (~@ v -> t)

  boolean : type

  true : boolean
  false : boolean


  (the boolean true)
  true :2 boolean

  (the boolean (not true))
  false :2 boolean



  (For b )



  For t v (~@ new t v) -> (~@ v : t)

  (not true) : boolean
  


  For f v r .

  not boolean : boolean
  not -> (For a r (implies (and (= r boolean)
                                (= a boolean))
                           (not a)))

  and boolean .. : boolean
  or boolean .. : boolean
  implies boolean boolean : boolean

; end


  For f at rt
  (f : at .. -> rt)
  ->
  (For rrt
   (implies (and (= rt rrt)
                 (a : t) ..)
            (f )
          

  (not : boolean -> boolean)
  (For rrt a
   (not )

  type -> type

  boolean : type

  true : boolean
  false : boolean

  not : boolean -> boolean
  or : boolean .. -> boolean
  and : boolean .. -> boolean
  implies : boolean boolean -> boolean

; scratch




  (all (f a a-t r-t)
    ((f (a : a-t) ..) : r-t)
    ->
    (all (requested-r-t)
      ((f a ..) : requested-r-t)
      ->
      (implies (and (= requested-r-t r-t)
                       (a : a-t) ...)
               (f a ..))))

  ((not (b : boolean) ..) : boolean)
  ->
  (all (requested-r-t)
    ((not b ..) : requested-r-t)
    ->
    (implies (and (= requested-r-t boolean)
                  (b : boolean))
             (not b ..)))




  boolean -> boolean

  (true : boolean) -> true
  (false : boolean) -> false







  (apply (all (f a a-t requested-r-t)
           ((f (a : a-t) ..) : requested-r-t)
           ->
           (implies (and (= requested-r-t r-t)
                         (a : a-t) ..)
                    (f a ..)))
         (all (f a a-t r-t)
           (fn (f (a : a-t) ..) -> r-t)))


  (all (f a a-t r-t)
    ((f (a : a-t)) : r-t)
    ->
    (all (requested-r-t)
      ((f a ..) : requested-r-t)
      ->
      (implies (and (= requested-r-t r-t)
                       (a : a-t) ...)
               (f a ..))))




  (all (l r o)
    (begin l : r o ..)
    ->
    (#%begin (: l r) (begin o ..)))

  (all (l r o)
    (begin l r o ..)
    ->
    (#%begin (: l r) (begin o ..)))

  (all (f a a-t r-t)
    (fn (f (a : a-t) ..) : r-t)
    ->
    (all (requested-r-t)
      ((f a ..) : requested-r-t)
      ->
      (implies (and (= requested-r-t r-t)
                       (a : a-t) ..)
               (f a ..))))

  type -> type

  boolean : type

  true : boolean
  false : boolean

  (not (b : boolean)) : boolean


  (fn (not (b : boolean)) -> boolean)
  (fn (and (b : boolean) ..) -> boolean)
  (fn (or (b : boolean) ..) -> boolean)
  (fn (implies (b1 : boolean) (b2 : boolean)) -> boolean)



  (fn (not (b : boolean)) -> boolean)
  ->
  (all (requested-return-type)
    ((not b) : requested-return-type)
    ->
    (implies (and (= requested-return-type boolean)
                  (b : boolean))
             (not b)))

  (all (f b t1 t2)
    (fn (f (~@ b : t1) ..) -> t2)
    ->
    (all (b1 t3)
      (: (f b1 ..) t3)
      ->
      (implies (and (= t3 t2)
                    (: b1 b) ..)
               (f b1 ..))))

  (fn (not (b : boolean)) -> boolean)

  (all (b t)
    (: (not b) t)
    ->
    (implies (and (= t boolean)
                  (: b boolean))
             (not b)))

  (all (b t)
    (: (and b ..) t)
    ->
    (implies (and (= t boolean)
                  (and (: b boolean) ..))
             (and b ..)))


(: $b boolean) -> (or (= $b true) (= $b false))


(all (b t)
  (: (not b) t))
->
(implies (and (= t boolean)
              (: b boolean))
         (not b))

(: (not $b) $t) -> (implies (and (= $t boolean)
                                 (: $b boolean))
                            (not $b))


(: (not 123) boolean)
->
(implies (and (= boolean boolean)
              (: 123 boolean))











(and) -> true
(and false $b ..) -> false
(and true $b ..) -> (and $b ..)
(: (and $b ..) $t) -> (implies (= $t boolean) (and $b ..))

(or) -> false
(or true $b ..) -> true
(or false $b ..) -> (or $b ..)
(: (or $b ..) $t) -> (implies (= $t boolean) (or $b ..))

(implies $x $y) -> (or (not $x) $y)
(: (implies $x $y) $t) -> (implies (= $t boolean) (implies $x $y))

(: (: $x $t1) $t2)
->
(implies (: $t1 $t2) (: $x $t2))



(: (not true) true)
->
(implies (= true boolean)
         (not true))
->
(or (not (= true boolean))
    (not true))
->




(: (not true) boolean)
->
(implies (= boolean boolean) (not true))
->
(or (not (= boolean boolean))
    (not true))
->
(or (not true)
    (not true))
->
(or false (not true))
->
(or (not true))
->
(or false)
->
true

; (: (: true boolean) type)
; ->
; (implies (: boolean type) (: true type))
; ->
; (or (not (: boolean type)) (: true type))
; ->
; (or (not true) (: true type))
; ->
; (or false (: true type))
; ->
; true
