Notation:

  1. Y/X means that the term Y has scope-set X.

  2. Y/X+{Z} means that term Y has scope-set (X union {Z}) for some
     scope Z.

  2. 'next scope S' is a scope unique to an environment.

Definition [let]:

  ; In environment E with next scope S,
  (let [<pattern>/SP <result>/SR]
    <body>/SB)
  --> 
  ; in environment extended with (Rule <pattern>/SP+{S} <result>/SR)
  <body>/SB+{S}
  ; but only if the new environment is defined, i.e., only the new
  ; rule is pairwise-deterministic with the rules of E.

Definition of [letrec]: Exactly the same as [let] except that the
reduction has <result>/RS+{S} instead of <result>/RS. This allows
<result> to refer to terms in <pattern>.

  Why both 'let' and 'letrec'? Because I want both of the following
  programs to work:

    (let [x 10]
      (let [x x]
        x))
    --> 10 ; OK: 10 is a fixed-point
    
    (let [x 10]
      (letrec [x x]
        x))
    --> x ; OK: x is a fixed-point

  More specifically, we need to be able to define terms like (Some $x)
  as fixed-points. You need letrec to do this:

    (let [(Some 10) (Some 10)]
      (Some 10))
    --> (Some 10)
    --> ERROR! No rule to re-write (Some x), but (Some x) is not a
        fixed-point.

    ; This is because the (Some 10) on the RHS does not have the scope
    ; that was added to the LHS and the body of the let.

  ... but we also want to be able to shadow rules, so 'let' is
  necessary.

Definition of [begin]: 'begin' is defined as the following rule in the
top-level scope (but only defined if the condition specified later
applies):

    (Rule (begin $main (def $pattern $result) ...)
      (letrec [$pattern $result] ...
        $main))
  
  Condition: For the environment E into which this rule is being
  introduced there does not exist a rule in E available at the top-level
  scope that is nondeterministic with respect to the above rule (i.e.,
  if someone wants to implement their own rule for 'define', they can,
  and it won't conflict with this one, because this one wouldn't be
  defined in E if they defined their own).
  
  The language environment should, when running code, wrap the code in
  (begin ....). Then, you could write a program like this:
  
    ; my-file.lang
    
    (factorial 10)
  
    (def (factorial $n) (factorial $n 1))
    (def (factorial $n $acc)
      (if (= $n 0)
          acc
  	(factorial (- $n 1)
  	           (* $n $acc))))
  
  This would get compiled as:
  
    (letrec [(factorial $n) (factorial $n 1)]
            [(factorial $n $acc)
             (if (= $n 0)
                 acc
                  (factorial (- $n 1)
                             (* $n $acc)))]
      (factorial 10))
  
  Which avoids the need to explicitly write everything in a 'letrec'.
  
  And if you wanted to implement your own way of restructuring programs,
  you could simply write a new (Rule (begin ....) ....) in the top-level
  scope and supply it in every environment in which you want to run
  code.
  
  'begin' is kind of like a blending of '#%module-begin' and 'begin0' in
  racket.
  
  Note: This 'default begin' is still available in nested scopes, so if
  you wanted to write 'def' inside of a 'let', you could do so:
  
    (let [food "pizza"]
      (begin (make-crazy food)
        (def (make-crazy $food)
          (make-crazier (+ "ice cream" " " $food)))
        (def (make-crazier $food)
          (+ "chocolate covered" " " $food))))
    -->
    (begin (make-crazy food)
      (def (make-crazy $food)
        (make-crazier (+ "ice cream" " " $food)))
      (def (make-crazier $food)
        (+ "chocolate covered" " " $food)))
    -->
    (letrec [(make-crazy $food)
             (make-crazier (+ "ice cream" " " $food))]
            [(make-crazier $food)
             (+ "chocolate covered" " " $food)]
      (make-crazy food))
    -->
    (make-crazy food)
    -->
    (make-crazier (+ "ice cream" " " food))
    -->
    (+ "chocolate covered"
       (+ "ice cream" " " food))
    -->
    (+ "chocolate covered" " "
       (+ "ice cream" " " "pizza"))
    -->
    (+ "chocolate covered" " " "ice cream pizza")
    -->
    "chocolate covered ice cream pizza" ; OK: reached a fixed-point.

Definition of [undefined]: There exists a term, 'undefined', which is
not a fixed-point and does not reduce to a fixed-point.

Definition of [unsequence]: (unsequence <reduce-me> <if-successful>
<if-fails>) is defined as <if-successful> IF <reduce-me> CAN BE
reduced to a fixed-point. If <reduce-me> reduces to a term Q to which
there are no available rules for rewriting Q, the 'unsequence' form is
defined as <if-fails>.

  IMPORTANT! WARNING! The order of reduction of <reduce-me>,
  <if-successful>, and <if-fails> is not specified. An implementation
  could, potentially, try to reduce them all in parallel. To sequence
  reductions that have side effects (which may be provided by an
  implementation) use 'sequence'.

Definition of [sequence]: (sequence <reduce-me> <if-successful>
<if-fails>) is defined as <if-successful> WHEN <reduce-me> IS reduced
to a fixed-point. If <reduce-me> reduces to a term Q to which there
are no available rules for rewriting Q, the 'sequence' form is defined
as <if-fails>.

  Note: the reduction order is defined as follows.

    1. Attempt to reduce <reduce-me> to a fixed-point.

    2. If (1) worked, reduce to <if-successful>.

    3. If (1) failed, reduce to <if-fails>.

  It is defined that AT MOST ONE of <if-successful> OR <if-fails> will
  be reduced (any amount). (AT MOST ONE because the reduction of
  <reduce-me> may never halt).

    (begin (reduce-in-order (print document.txt-contents)
                            (delete document.txt-filename))
      (def (reduce-in-order $term1 $term2)
        (sequence $term1 $term2 undefined))
      (def document.txt-contents
        (lang.stdlib.impure.read-file document.txt-filename))
      (def (delete $file)
        (lang.stdlib.impure.delete-file $file))
      (def document.txt-filename "document.txt"))
     
    (letrec [doc (lang.stdlib.impure.read-file "document.txt")]
         [print-doc-content
      (sequence
       doc
       (begin print&delete
         (def print&delete
           (sequence
            (builtins.stdlib.impure.print doc)
             (builtins.stdlib.impure.delete-file "document.txt")
             undefined)))
       undefined))
    -->
    (sequence
     doc
     (begin print&delete
       (def print&delete
         (sequence (builtins.stdlib.impure.print doc)
                   (builtins.stdlib.impure.delete-file "document.txt")
                   undefined)))
     undefined)
    -->
    (sequence
     <document-contents>
     (begin print&delete
       (def print&delete
         (sequence (builtins.stdlib.impure.print <document-contents>)
                   (builtins.stdlib.impure.delete-file "document.txt")
                   undefined)))
     undefined)
Definitions of [fence-accept] [fence-release]: (fence-release <T>)
reduces to <T> (it is the identity function). (fence-accept <T>)
reduces to <T> if and only if (fence-release <T>) has already been
reduced to a fixed-point. If (fence-release <T>) reduces to a term Q
where there are no rules for rewriting Q, (fence-accept <T>) is
defined as [undefined].

   This is useful for ordering the reduction of terms that have side
   effects. Here's an example of using fences to do the following in
   this order: (1) read a file; (2) print its contents and delete
   it. Note that the example does not specify the order of printing
   and deleting, just that it will have read the file before it does
   either of those things.

   Also, for the purposes here, assume that '(builtins.stdlib.impure.*
   ....)' forms reduce to fixed-points.

   (letrec [doc (lang.stdlib.impure.read-file "document.txt")]
           [perform-read (fence-accept doc)]
           [doc-contents (fence-release doc)]
     (seq perform-read
          (let [print&delete
                (seq (builtins.stdlib.impure.print doc-contents)
                     (builtins.stdlib.impure.delete-file
                      "document.txt")
                     undefined)]
            print&delete)
          undefined))
   -->
   (seq perform-read
        (let [print&delete
              (seq (builtins.stdlib.impure.print doc-contents)
                   (builtins.stdlib.impure.delete-file
                    "document.txt")
                   undefined)]
          print&delete)
        undefined)

   From this point, there are many possible ways that reduction can
   occur. I will only consider the 'evil demon' implementation of
   'seq' which tries to reduce itself in a way as to attempt to cause
   as many concurrency errors as possible. In this case, I'll make it
   reduce its second argument as far as it can, and only then reduce
   its first argument.

   -->
   (seq perform-read
        print&delete
        undefined)
   -->
   (seq perform-read
        (seq (builtins.stdlib.impure.print doc-contents)
             (builtins.stdlib.impure.delete-file
              "document.txt")
             undefined)
        undefined)
   -->

Definition of [freeze-pattern-scopes]: (freeze-pattern-scopes <R>) is
defined if <R> reduces to a rule and the following condition holds:
the scope-set of the pattern of <R> is a non-strict superset of the
scope-set of the result of <R>. In other words, (freeze-pattern-scopes
<R>) is not available in more-nested scopes.

  This is useful for implementing a Haskell-style IO Monad. Here we
  want to write code that executes the IO Monad, but we only want this
  to be done at the top-level (i.e., we don't want to allow reducing
  the term (IO <X>) in a nested scope). For example, the following
  code could be an implementation of 'begin' that would make a program
  run in an environment containing the rule not able to use 'begin' in
  a nested scope (to perform an IO action in a seemingly-pure
  context):

  (freeze-pattern-scopes
   (Rule (begin $main (def $pattern $result) ...)
         (letrec [$pattern $result] ...
           ; pretend that there exists a rule to re-write the
           ; unsafe-perform-IO form to a series of 'sequence' forms.
           (unsafe-perform-IO $main))))

  In an environment containing the previous rule, the following
  reduction could occur:

  (let [doc (lang.stdlib.pure.read-file "document.txt")]
    ; it would make sense here that (lang.stdlib.pure.read-file ....)
    ; reduces to a fixed-point (IO <X>).
    (begin doc))
  --> (begin doc)
  --> ERROR! No rules for rewriting '(begin doc)'. The closest is
      '(begin $result (def $pattern $result) ...)', but that rule is
      FROZEN as to not be available in more-nested scopes.

Definition of [noreduce]: The following rule exists in the top-level
environment:

    (Rule (noreduce $) undefined)

  ... which is technically speaking an infinite series of rules---one
  rule for each thing you could put in '$'---which ignores all of its
  subterms and reduces to 'undefined'.

  This is useful for implementing pure rules using impure rules. While
  purely-functional data structures are great, they can't do
  everything. Sometimes the need for speed and space requires that we
  use impurity. But it IS possible to write a rule that (1) doesn't
  mutate its arguments, (2) always returns the same result for the
  given arguments, and (3) uses mutation internally to do some
  computation in a way that would be too slow or too space intensive
  using purely-functional data structures. I think it would be
  reasonable to call this rule 'pure', as the impurity inside of it is
  merely an implementation detail of the rule; no one would know
  otherwise if it was implemented using purely-functional data
  structures (except that they might notice it taking longer to reduce
  or taking more memory to reduce).

    ; For example, the implementation of a standard library could
    ; contain the following rules which allow the creation of an
    ; 'Internally-Mutable-Vector' that can't be reduced which is just
    ; a wrapper around an (assuming) already-defined Mutable-Vector.

      mutable-vector-env+sequence-many-env

      (def mutable-vector-env+sequence-many-env
        (Env m:new
             m:mutable->immutable
             m:set!
             m:sequence-many1
             m:sequence-many*))

      (def m:new
        (Rule (new Internally-Mutable-Vector $size)
          (begin (helper Internally-Mutable-Vector)
            (def (helper $term-with-outside-scope)
              (let
                (noreduce ($term-with-outside-scope (new lang.builtins.Mutable-Vector $size))))))))

      (def m:mutable->immutable
        (Rule (mutable->immutable
               (noreduce (Internally-Mutable-Vector $v)))
              (mutable->immutable $v)))
      
      (def m:set!
        (Rule (Internally-Mutable-Vector (noreduce $v))
              $index
              $value)
          (set! $v $index $value))

      ; the following is useful for performing a lot of set!
      ; operations:
      (def m:sequence-many1
        (Rule (sequence-many $term0) $term0))
      (def m:sequence-many*
        (Rule (sequence-many $term0 $terms ...+)
          (sequence $term0
                    (sequence-many $terms ...)
                    undefined)))

    ; If these rules were present in our environment and we attempted
    ; to return this 'Internally-Mutable-Vector', it wouldn't work:

      (let [v (new Internally-Mutable-Vector 2)]
        (sequence-many (set! v 0 "a")
                       (set! v 1 "b")
                       v)) ; here we try to return 'v'
      -->
      (sequence-many (set! v 0 "a")
                     (set! v 1 "b")
                     v)
      -->
      (sequence (set! v 0 "a")
                (sequence-many (set! v 1 "b") v)
                undefined)
      -->
      (sequence (set! (new Internally-Mutable-Vector 2) 0 "a")
                (sequence-many (set! v 1 "b") v)
                undefined)
      -->
      (sequence (set! (noreduce (Internally-Mutable-Vector m)) 0 "a")
                (sequence-many (set! v 1 "b") v)
                undefined)
      -->
      (sequence (set! m 0 "a")
                (sequence-many (set! v 1 "b") v)
                undefined)
      -->
      (sequence (set! (new lang.builtins.Mutable-Vector 2) 0 "a")
                (sequence-many (set! v 1 "b") v)
                undefined)
      --> ; assuming that 'new' rule on lang.builtins.Mutable-Vector
          ; returns the fixed-point mutable vector representation
          ; '<builtin-mut-vec>':
      (sequence (set! <builtin-mut-vec> 0 "a")
                (sequence-many (set! v 1 "b") v)
                undefined)
      --> ; assuming that the 'set!' rule on '<builtin-mut-vec>'
          ; returns '<builtin-mut-vec>' itself after setting the value
          ; at the index in the vector:
      (sequence <builtin-mut-vec>
                (sequence-many (set! v 1 "b") v)
                undefined)
      -->
      (sequence-many (set! v 1 "b") v)
      -->
      (sequence (set! v 1 "b")
                (sequence-many v)
                undefined)
      -- .... -->
      (sequence (set! <builtin-mut-vec> 1 "b")
                (sequence-many v)
                undefined)
      -->
      (sequence-many v)
      -->
      v
      --> ; at this point, due to sequencing, the mutable vector
          ; inside of 'v' has already long been fully reduced to a
          ; fixed-point, even though 'v' itself has not been. I'm
          ; writing this to explain that even though 'v' reduces to
          ; '(new Internally-Mutable-Vector 2)', it's not the case
          ; that this creates a 'new' vector: it is the same one that
          ; has been being mutated this whole time.
      (new Internally-Mutable-Vector 2)
      -->
      (noreduce (Internally-Mutable-Vector m))
      --> ; ERROR: attempt to REDUCE THE IRREDUCIBLE!

    ; But can't we 'break the system' by doing this?

      (def (impure-unwrap (Internally-Mutable-Vector (noreduce $v)))
        $v)

      (let [v (new Internally-Mutable-Vector 2)]
        (sequence-many (set! v 0 "a")
                       (set! v 1 "b")
                       (impure-unwrap v)))
      -- .... -->
      <builtin-mut-vec>

    ; Well, of course you can. But why would you?
   
    ; Here we will implement an algorithm that takes an integer N as
    ; input and returns an immutable vector of size N, after filling
    ; it with some data. Exactly what data goes in the vector is not
    ; specified here, but filling the vector with data should involve
    ; lots of expensive operations that would be hard to do in a
    ; purely-functional way.
    
    (Rule (pure-algorithm $arg)
          (pure-algorithm/internal-mutation $arg))

    (def (sequence-many $term0 $term ...+)
      (sequence $term0
                (sequence-many $term ...)
                undefined))

    (def (pure-algorithm/internal-mutation $arg)
      (let [v (new mutable-vector:internal $arg)]
        (sequence v
                  (begin (mutable-vector:internal->immutable-vector v)
                    ....))))
