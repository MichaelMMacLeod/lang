(P1 B C) -> R
(P2 C B) -> R
A -> B
B -> C
R -> R
P1 -> P1
P2 -> P2

1 A B
2 B C
3 R R
4 P1 P1
5 P2 P2
6 (P1 B C) R
7 (P2 C B) R

0 0
0 1
2 1 C
3 R R
4 P1 P1
5 P2 P2
6 (P1 1 C) R



(B C) -> R
(C B) -> R
A -> B
B -> C
R -> R

1 A B
2 B C
3 R R
4 (B C) R
5 (C B) R

1 B
2 B C
3 R R
4 (B C) R
5 (C B) R

1 2
2 C
3 R R
4 (2 C) R
5 (C 2) R

1 2
2 C
3 3
4 (2 C) 3
4 (C 2) 3






(B C) -> R
(C B) -> R
A -> B
B -> C
R -> R
-----
1. A -> B
2. B -> C
3. R -> R
4. (B C) -> R
5. (C B) -> R
-----
1. A -> 1
2. 1 -> C
3. R -> R
4. (1 C) -> R
5. (C 1) -> R
-----
1. A -> 1
2. 1 -> 2
3. R -> R
4. (1 2) -> R
5. (2 1) -> R
-----
1. A -> 1
2. 1 -> 2
3. 3 -> 3
4. (1 2) -> 3
5. (2 1) -> 3


(sequence $result) --> $result

(sequence (: $r Rule)
  $others ...
  $result)
-->
(sequence $others ... $result)
; except that the rule $r is applied to $others and $result.


(Pair (: $x Signed-Integer) (: $y i8)) --> ....
(Pair (: $x i8) (: $y Signed-Integer)) --> ....

(Pair 0i8 0i8)
-->
(Pair (: 0i8 i8) 0i8)
-->
(Pair (: 0i8 i8) (: 0i8 0i8))
-->
()

(Pair (widen 0i8 Signed-Integer) 0i8)

(Pair 0i8 0i8)
-->
(Pair (: 0i8 i8) 0i8)
.... -->
(Pair (: 0i8 Term) 0i8)
.... -->
(Pair (: 0i8 Term) (: 0i8 Term))
--> ERROR!

(new Rule-Option-Set (: $option Rule-Option) ...)
-->
(Rule-Option-Set (new Set $option ...))


(sequence
  (Rule delimiter (new Continuation-Delimiter)
    (Rule-Options
      Eagerly-Reduce-Result))
  (continuation-delimit delimiter
    (+ 1 2
       (continuation-capture delimiter
         [C (C 7)]))))
-->
(sequence
  (: (Rule delimiter (new Continuation-Delimiter))
     Rule)
  (continuation-delimit delimiter
    (+ 1 2
       (continuation-capture delimiter
         [C (C 7)]))))
-->
(sequence
  [delimiter <continuation-delimiter>]
  (continuation-delimit delimiter
    (+ 1 2
       (continuation-capture delimiter
         [C (C 7)]))))
-->
(sequence
  (continuation-delimit #0=<continuation-delimiter>
    (+ 1 2
       (continuation-capture #0#
         [C (C 7)]))))
-->
(continuation-delimit #0=<continuation-delimiter>
  (+ 1 2
     (continuation-capture #0#
       [C (C 7)])))
-->
(+ 1 2
   (continuation-capture #0#
     [C (C 7)]))
-->
(+ 1 2 (C 7))
-->
(+ 1 2 (+ 1 2 7))
-->
(+ 1 2 10)
-->
12

(anf-transform
 (* (+ 1 2) (+ 3 4)))
-->
(sequence
  [x0 (+ 1 2)]
  [x1 (+ 3 4)]
  (* x0 x1))



(+-impl ($fixed ...) $intermediate
        ((: $x0 Fixed-Point-Term) $x ...))
-->
(+-impl ($x0 $fixed ...) $intermediate ($x ...))

(+-impl $fixed ($intermediate ...)
        ((: $x0 Intermediate-Term) $x ...))
-->
(+-impl)

(+)
-->
additive-identity




(replace (continuation-delimit delimiter
           (+ 1 2 (continuation-capture delimiter
                    [$C ($C 7)])))
  [delimiter (new Continuation-Delimiter)])
-->
(Sequence ([delimiter (new Continuation-Delimiter)])
 (continuation-delimit delimiter
   (+ 1 2 (continuation-capture delimiter
            [$C ($C 7)]))))
-->
(Sequence ([delimiter <continuation-delimiter>])
 (continuation-delimit delimiter
   (+ 1 2 (continuation-capture delimiter
            [$C ($C 7)]))))
-->
(Sequence ()
 (continuation-delimit #0=<continuation-delimiter>
   (+ 1 2 (continuation-capture #0#
            [$C ($C 7)]))))
-->
(continuation-delimit #0=<continuation-delimiter>
  (+ 1 2 (continuation-capture #0#
           [$C ($C 7)])))
-->
(+ 1 2 (continuation-capture #0#
         [$C ($C 7)]))
-->
(+ 1 2 (<continuation> 7))
-->
(+ 1 2 (+ 1 2 7))
-->
(+ 1 2 10)
-->
12

-->
(Continue [delimiter (new Continuation-Delimiter)]
 (Return (continuation-delimit delimiter
           (+ 1 2 (continuation-capture delimiter
                    [$C ($C 7)])))))
-->
(let (sequence
      delimiter
      (continuation-delimit delimiter
        (+ 1 2 (continuation-capture delimiter
                [$C ($C 7)]))))
  [delimiter (new Continuation-Delimiter)])
-->
(sequence
 delimiter
 (continuation-delimit delimiter
   (+ 1 2 (continuation-capture delimiter
           [$C ($C 7)]))))
-->
(sequence
 #0=delimiter
 (continuation-delimit #0#
   (+ 1 2 (continuation-capture #0#
           [$C ($C 7)]))))
-->
(sequence
 #0=(new Continuation-Delimiter)
 (continuation-delimit #0#
   (+ 1 2 (continuation-capture #0#
           [$C ($C 7)]))))
-->
(sequence
 #0=<delimiter>
 (continuation-delimit #0#
   (+ 1 2 (continuation-capture #0#
           [$C ($C 7)]))))
-->
(continuation-delimit #0=<delimiter>
  (+ 1 2 (continuation-capture #0#
           [$C ($C 7)])))
-->
(+ 1 2 (continuation-capture #0#
         [$C ($C 7)]))
-->





(sequence delimiter)

(sequence b1 (sequence delimiter b1))


(let (let (let (sequence b1 b2 b2)
            [b2 (sequence delimiter b1 b1)])
       [delimiter (new Continuation-Delimiter)])
  [b1
   (continuation-delimit delimiter
     (+ 1 2 (continuation-capture delimiter
              [$C ($C 7)])))])
-->
(let (let (sequence b1 b2 b2)
       [b2 delimiter])
  [delimiter (new Continuation-Delimiter)])
-->
(let (sequence b1 b2 b2)
  [b2 delimiter])
-->
(sequence b1 b2 b2)
-->
(sequence
 (continuation-delimit delimiter
   (+ 1 2 (continuation-capture delimiter
            [$C ($C 7)])))
 b2
 b2)
-->
b2
-->
(sequence delimiter )



-->
(let (sequence b (sequence delimiter b b) (sequence delimiter b b))
  [delimiter (new Continuation-Delimiter)])
-->
(sequence b (sequence delimiter b b))




(let (sequence
      delimiter
      (continuation-delimit delimiter
       (+ 1 2 (continuation-capture delimiter
                [$C ($C 7)])))
      (continuation-delimit delimiter
       (+ 1 2 (continuation-capture delimiter
                [$C ($C 7)]))))
  [delimiter (new Continuation-Delimiter)])

(continuation-delimit delimiter
  (+ 1 2 (continuation-capture delimiter
           [$C ($C 7)])))
-->
(continuation-delimit delimiter
  (+ 1 2 (continuation-capture delimiter
           [$C ($C 7)])))


(let (+ 2 3 (continuation-delimit (apply + 2 3) id))
  [(f $delimiter)
   (continuation-capture $delimiter )])
-->
(continuation-delimit f id)
-->
(f <delimiter>)
-->
(continuation-capture <delimiter> id)
-->
(id <continuation>)
-->
<continuation>
-->
(: <continuation> Continuation)
-->
(: <continuation> Fixed-Point-Term)











(let (continuation-delimit f id)
  [(f $delimiter)
   (continuation-capture $delimiter id)])
-->
(continuation-delimit f id)
-->
(f <delimiter>)
-->
(continuation-capture <delimiter> id)
-->
(id <continuation>)
-->
<continuation>
-->
(: <continuation> Continuation)
-->
(: <continuation> Fixed-Point-Term)

Number {
  Integer {
    Real-Integer {
      Positive-Real-Integer {
        Positive-{u,i}{8..128}
      }
      Nonpositive-Real-Integer {
        Zero-Integer {
          Zero-{u,i}{8..128}
        }
        Negative-Integer {
          Negative-{i}{8..128}
        }
      }
    }
    Complex-Integer {
      Po            
    }
  }
  Float {
  }
}

(Some 10)
-->
(: (Some 10) Optional)
-->
(: (Some 10) Singular-Term)
-->
(: (Some 10) Term)
; Done. (Some 10) is a Term.

x
-->
(: x Identifier)
-->
(: x Atom-Term)
-->
(: x Any)
--> ERROR! no rule to rewrite (: x Term)

(x)
-->
(: (x) Compound-Term)
-->
(: (x) Any)
--> ERROR! no rule to rewrite (: (x) Term)

10
-->
(: 10i32 i32)
-->
(: 10i32 Signed-Integer)
-->
(: 10i32 Integer)
-->
(: 10i32 Atom-Term)
-->
(: 10i32 Term)
--> ERROR! no rule to rewrite (: 10i32 Term)

(sign -12)
--> (sign (: -12i32 i32))
--> Negative

(sign 12u8)
--> (sign (: 12u8 u8))
--> Positive

(sign -0i32)
--> (sign (: -0i32 u8))
--> Zero

(sign -0.0)
--> (sign (: -0.0f32 f32))
--> Negative

(Rule (with-unique-token (: $token Identifier) $result)
  (let (sequence $result (sequence token undefined $result))
    [token $token]))
-->


(with-unique-tokens (Optional-Impl)
  (Env (Pattern-Rule Optional Optional-Impl)
       (Rule (Some $x) (: (Some $x) Optional-Impl))))
-->
(let (sequence result (sequence Optional-Impl undefined result))
  [result (Env (Pattern-Rule Optional Optional-Impl)
               (Rule (Some $x) (: (Some $x) Optional-Impl)))]
  [Optional-Impl (let Optional-Impl)])
-->
(sequence result (sequence Optional-Impl undefined result))
-->
(sequence #0=result (sequence Optional-Impl undefined #0#))
-->
(sequence
 #0=(Env (Pattern-Rule Optional Optional-Impl)
         (Rule (Some $x) (: (Some $x) Optional-Impl)))
 (sequence Optional-Impl undefined #0#))
-->
(sequence
 Optional-Impl
 undefined
 (Env (Pattern-Rule Optional Optional-Impl)
      (Rule (Some $x) (: (Some $x) Optional-Impl))))
-->
(sequence
 #0=Optional-Impl
 undefined
 (Env (Pattern-Rule Optional #0#)
      (Rule (Some $x) (: (Some $x) #0#))))
-->
(sequence
 #0=(let Optional-Impl)
 undefined
 (Env (Pattern-Rule Optional #0#)
      (Rule (Some $x) (: (Some $x) #0#))))
-->
(sequence
 #0=Optional-Impl/l
 undefined
 (Env (Pattern-Rule Optional #0#)
      (Rule (Some $x) (: (Some $x) #0#))))
-->
(Env (Pattern-Rule Optional Optional-Impl/l)
     (Rule (Some $x) (: (Some $x) Optional-Impl/l)))
; Done.



(let (unsequence Optional-Impl result)
 [result (Env (Pattern-Rule Optional Optional-Impl)
                 (Rule (Some $x) (: (Some $x) Optional-Impl)))]
 [Optional-Impl (scope Optional-Impl)])
-->
(unsequence Optional-Impl result)
-->
(unsequence Optional-Impl
 (Env (Pattern-Rule Optional Optional-Impl)
      (Rule (Some $x) (: (Some $x) Optional-Impl))))
-->
(unsequence #0=Optional-Impl
 (Env (Pattern-Rule Optional #0#)
      (Rule (Some $x) (: (Some $x) #0#))))
-->



(Rule (~protect Unchecked-Optional))
(Rule fake-optional
      (: (Some Hello world) Optional))


(let (sequence x (* 2 x) (* 3 x))
  [x (+ 3 4)])
-->
(sequence x (* 2 x) (* 3 x))
-->
(sequence-reduce #0=x (* 2 #0#) (* 3 #0#))
-->
(sequence-reduce #0=(+ 3 4) (* 2 #0#) (* 3 #0#))
-->
(sequence-reduce #0=5 (* 2 #0#) (* 3 #0#))
-->
(* 2 #0#)
-->
(* 2 5)
-->
10

(reduce
 (Graph (* 2 (ref 0))
   [(ref 0) x])

(let (sequence x x undefined)
  [x (+ 2 3)])
-->
(sequence x x undefined)
-->
(sequence #0=(+ 2 3) #0# undefined)
-->
(sequence #0=5 #0# undefined)
-->
5

(+ 1
   2
   (let (continuation-prompt calculate catch)
     [(calculate $prompt)
      (continuation-abort $prompt (+ 3 4))]
     [(catch $term)
      (+ $term 5 6)]))
-->
(+ 1
   2
   (continuation-prompt calculate catch))
-->
(+ 1
   2
   (delimited-by <prompt> (calculate <prompt>)))
-->
(+ 1
   2
   (delimited-by <prompt> (continuation-abort <prompt> (+ 3 4))))
-->
(+ 1
   2
   (delimited-by <prompt> (catch (+ 3 4))))
-->
(+ 1
   2
   (delimited-by <prompt> (+ (+ 3 4) 5 6)))
-->
(+ 1
   2
   (delimited-by <prompt> (+ 7 5 6)))
-->
(+ 1
   2
   (delimited-by <prompt> 18))
-->
(+ 1
   2
   18)
-->
21


(dynamic-wind (print "enter")
              (+ 2 3)
              (print "exit"))
--> ; "enter" printed
(+ 2 3)
-->
5   ; "exit" printed

(let (continuation-prompt f id)
  [(f $prompt)
   (dynamic-wind (print "enter")
                 (continuation-abort $prompt (+ 2 3))
                 (print "exit"))])
-->
(continuation-prompt f id)
-->
(f <prompt>)
-->
(dynamic-wind (print "enter")
              (continuation-abort <prompt> (+ 2 3))
              (print "exit"))
--> "enter" printed
(continuation-abort <prompt> (+ 2 3))
--> "exit" printed
(id (+ 2 3))
-->
(+ 2 3)
-->
5

(let (continuation-prompt f id)
  [(f $prompt)
   (dynamic-wind (print "enter")
                 (continuation-abort $prompt (+ 2 3))
                 (print "exit"))])


(let (with-handler printing-exception-handler
       (+ 1 2 (raise 3)))
  [(printing-exception-handler $exception)
   (print $exception)])
-->
(with-handler printing-exception-handler
  (+ 1
     2
     (raise 3)))
-->
(let (continuation-prompt body printing-exception-handler)
  [(body $prompt)
   (let (+ 1 2 (raise 3))
     [current-exception-handler-prompt $prompt])])
-->
(continuation-prompt body printing-exception-handler)
-->
(body <prompt>)
-->
(let (+ 1 2 (raise 3))
  [current-exception-handler-prompt <prompt>])
-->
(+ 1 2 (raise 3)
-->
(+ 1 2 (abort-current-continuation
        current-exception-handler-prompt
        3))
-->
(+ 1 2 (abort-current-continuation <prompt> 3))
-->
(printing-exception-handler 3)
-->
(print 3)
--> 3 is printed
() ; Done.

(with-handler $H $body)
-->
(let (continuation-prompt body $H)
  [(body $prompt)
   (let $body
     [current-exception-handler-prompt $prompt])])

(raise $exception)
-->
(abort-current-continuation
 current-exception-handler-prompt
 $exception) 

(: <D> Continuation-Delimiter)

  A fixed-point term 

(try-dynamic-wind <on-enter> <body> <on-exit>)

  Like <body>, except that <on-enter> is reduced to a fixed-point for
  its side effects each time control enters <body> and <on-exit> is
  reduced to a fixed-point for its side effects each time control
  exits <body>.

  The result is (Ok <body>), unless <on-enter> or <on-exit> failed to
  be reduced to a fixed-point, in which case the result is (Err
  (Irreducible <on-enter>)) or (Err (Irreducible <on-exit>))
  respectively.

  Note that if control enters or exits <body> multiple times,
  <on-enter> or <on-exit> are completely re-reduced each time, even if
  they had been reduced successfully to a fixed-point when control
  entered or exited previously. This ensures the side effects of
  <on-enter> and <on-exit> are (re)performed.

(continuation-capture <prompt> <term>)

  If <prompt> is not a continuation prompt, or if the current
  continuation is not delimited by <prompt>, reduces to
  'undefined'. Otherwise, Reduces to (<term> <C>), where <C> is the
  portion of the current continuation delimited at and above
  <prompt>. Does not remove any part of the current continuation (use
  continuation-abort for that).

(continuation-abort
 (:/{continuation-scope} <D> Continuation-Delimiter)
 <term>)

  Removes the portion of the current continuation delimited at and
  above <prompt> and reduces to (<catch> <term>), where <catch> is
  from the continuation-prompt term reduction which created
  <prompt>. Note that <prompt> is not installed on the resulting
  (<catch> <term>) term, so (<catch> <term>) itself cannot abort to
  <prompt>.

(continuation-delimit <body> <catch>)

  The same as (<body-delimited> <D>), where <body-delimited> is like
  <body> except that a continuation delimiter has been installed
  around it, with <D> being a term that reduces to the fixed-point
  term:

    (:/{continuation-scope} <D> Continuation-Delimiter)

  which is identical to <D> inside of itself but non-identical to all
  other <D>s created by other reductions of 'continuation-delimit'.

  If, during the reduction of (<body-delimited> <prompt>),
  (continuation-abort <prompt> <term>) is reduced, the overall
  continuation-prompt term means (<catch> <term>) instead.

(:continuation-delimiter <$-identifier>)

  (Rule (print (: $d Continuation-Delimiter))
        (print "continuation delimiter"))

  (Rule fake-delimiter
        (: "Surprise!" Continuation-Delimiter))

(open-file $name $h)
-->
(let (dynamic-wind open-handle ($h open-handle) close-handle)
  [open-handle (leaky-open-file $name)]
  [close-handle (leaky-close-file $name)])

(let (open-file "out.txt" print-greeting)
  [(print-greeting $handle)
   (print-line "Hello, world!" $handle)])
-->
(open-file "out.txt" print-greeting)
--> ; "out.txt" is opened
(open-file "out.txt" (print-line "Hello, world!" <handle>))
--> ; Hello, world! written to out.txt
(open-file "out.txt" ())
--> ; "out.txt" is closed
()


2u8 = (Ranges (2 3))
0u8 = (Ranges (0 1))
u8 = (Ranges (0 128))
(* r1 0u8) = 0u8
(* 0u8 r1) = 0u8
(/ (Ranges (b e) ...) 2u8) = (Ranges ((/ b 2) (/ e 2)) ...)
(+ (Ranges (b e) ...) (Ranges (b0 e0))) =

(run (Fast-Math ((: ))))


(define-type Range-Inclusive
  (All (a t l u)
    ((and (a : t)
          (l : t)
          (u : t))
     implies
     (and (l < a)
          (a <= u)))))

(u64 > 10)

(Unsigned 128-bit Integer)
(Unsigned 64-bit Integer)
(Unsigned 32-bit Integer)
(Unsigned 16-bit Integer)
(Unsigned 8-bit Integer)

(Signed 128-bit Integer)
(Signed 64-bit Integer)
(Signed 32-bit Integer)
(Signed 16-bit Integer)
(Signed 8-bit Integer)



(begin
  (def (: main u32)
    factorial-10)
  (def (: factorial (-> Number Number))
    (fn x
      (if (= x 0) 1 (* x (factorial (- x 1))))))
  (def factorial-10 : u32
    (factorial 10)))



(Program (language = ghc-9.8.1)
 begin-utf-8-string-ending-at END
   main :: IO ()
   main = putStrLn "Hello, world!"
 END)

(factorial $p)
--> (factorial $p 1)

(fn (factorial (x : u32) (acc : u32)) -> u32
  (match x
    0 => acc
    (n @ [1..]) => (factorial (x - 1) (n * acc))))
;;;

(factorial 10 1)
-->
  move r1 <- 1
  move r2 <- 10
LOOP:
  cmp r2 == 0 ? RET
  move r1 <- r1 * r2
  move r2 <- r2 - 1
  jmp LOOP
RET:
  ret r1


(factorial (Proof ($x is u32)) $acc)
--> (match $x
      0 => $acc
      (n @ [1..]) => (factorial ()))

(match (prove (input is u32))
  (Ok $proof) => (Ok (factorial $proof))
  $else => $else)

((* 1 2) k)
--> (k (* 1 2))

(stack-transform (CPS-transform (* (+ 1 2) (+ 3 4))))
-->
(stack-transform
 (Continue [k1 (+ 1 2)]
  (Continue [k2 (+ 3 4)]
   (Continue [k3 (* k1 k2)]
    (Return k3)))))
-->
((push 1 2)
 (call +)
 (push 3 4)
 (call +)
 (call *))

--> (Continue (Continue (Continue (Done k3)
                          [k3 (* k1 k2)])
                [k2 (+ 3 4)])
      [k1 (+ 1 2)])


--> (let (let (let (sequence-several k1 k2 k3)
                [k3 (* k1 k2)])
           [k2 (+ 3 4)])
      [k1 (+ 1 2)])
-->
(sequence-several k1 k2 k3)
-->
(sequence-several (+ 1 2) k2 k3)
-->
(sequence-several 3 k2 k3)
-->
(sequence-several 3 (+ 3 4) k3)
-->
(sequence-several 3 7 k3)
-->
(sequence-several #0=3 #1=7 (* #0# #1#))
-->
(sequence-several 3 7 21)
-->
21


--> (k
     (let (let (sequence-several (k1 k2) (* k1 k2) undefined)
            [k2 (+ 3 4)])
       [k1 (+ 1 2)]))


(let (let (sequence-several (k1 k2) (* k1 k2) undefined)
       [k2 (+ 3 4)])
  [k1 (+ 1 2)])
-->
(let (sequence-several (k1 k2) (* k1 k2) undefined)
  [k2 (+ 3 4)])
-->
(sequence-several (k1 k2) (* k1 k2) undefined)
-->
(sequence-several (#0=(+ 1 2) k2) (* #0# k2) undefined)
-->
(sequence-several (#0=3 k2) (* #0# k2) undefined)
-->
(sequence-several (#0=3 #1=(+ 3 4)) (* #0# #1#) undefined)
-->
(sequence-several (#0=3 #1=7) (* #0# #1#) undefined)
-->
(* 3 7)
-->
21


(+ (* x x) (* y y))
--> (CC k
     (* x x
      (CC k2
       (* y y
        (CC k3
         (+ k2 k3))))))
(run (* $x ... (CC $k)))
(run ((+ $x $y (CC $k1)) $k0))
--> ($k0 ($x ))

(run (CC $k (+ $x ... (CC $k2))))
--> ($k ($k2 (+ $x ...)))

(new (CPS Fast-Math) (Fast-Math (+ $x ...)) $k)
--> ($k (with-k k (new (CPS Fast-Math) $x k)))

(new (CPS Fast-Math) (Fast-Math {$x is u32}) $k)
--> ($k $x)

(new (CPS Fast-Math) $fm)
--> (letrec (new (CPS Fast-Math) $fm $k)
      [(k $x) $x])

--> ($k (u32:unsafe:+ $x) ...)


(try-new Fast-Math (+ 1 2 3))
--> (Ok (Fast-Math (+ 1 2 3)))

(try-new Fast-Math (let (* x y) [x 10] [y 20]))
--> (Err (proof {(let (* x y) [x 10] [y 20]) is-not Fast-Math}))

(run (Fast-Math {$x is u32}))
--> $x

(run (Fast-Math (+ $x ...)))
--> (u32:unsafe+ $x ...)

(prove {(+ $x ...) is fast-math})
--> {{(+ $x ...) is fast-math}
     if-and-only-if
     (all {$x is fast-math} ...)}

(prove {{$x is u32} is fast-math})
--> (proof {{$x is u32} is fast-math})

(prove {(+ 1 2 3) is fast-math})
-->
{{(+ 1 2 3) is fast-math}
 if-and-only-if
 (all {1 is fast-math} {2 is fast-math} {3 is fast-math})}
-->
{{(+ 1 2 3) is fast-math}
 if-and-only-if
 (all (proof {1 is fast-math})
      (proof {2 is fast-math})
      (proof {3 is fast-math}))}
-->
{{(+ 1 2 3) is fast-math}
 if-and-only-if
 (proof
  (all {1 is fast-math}
       {2 is fast-math}
       {3 is fast-math}))}
-->
(proof {(+ 1 2 3) is fast-math})




{(*) as (Optional (Matrix 2 2))}
--> (Optional:*-impl (Matrix 2 2) () (one))
--> (Some (* {one as (Matrix 2 2)}))
--> (Some (* (Matrix ((1 0) (0 1)))))
--> (Some (Matrix ((1 0) (0 1))))

{(* $x ...) as (Optional $t)}
--> (Optional:*-impl $t ($x ...) (one))

(Optional:*-impl $t () ($acc ...))
--> (Some (* {$acc as $t} ...))

(Optional:*-impl $t ((Some $x) $others ...) ($acc ...))
--> (Optional:*-impl $t ($others ...) ($x $acc ...))

(Optional:*-impl $ (None $ ...) $)
--> None

(Choice keep)
(Choice filter-out)

(try (u32 from 10u64))
-->
(let (sequence n (Some n) None)
  [n (u32 from 10u64)])
-->
(sequence n (Some n) None)
-->
(sequence #0=(u32 from 10u64) (Some #0#) None)
-->
(sequence #0=10u32 (Some #0#) None)
-->
(Some 10u32)

{one as (Optional u32)}
-->
(Some u32)


{(* $x ...) as (Optional $t)}
-->
(Optional:* {$x as (Optional $t)} ...)

(Optional:* {None as (Optional $t)})

(*)
--> one

{one as u32}
{one as i32}
{one as usize}
{one as (list-of u32)} --> (List {one as u32}) --> (List 1u32)
{one as 

{(*) as (Matrix 2 2)}
-->
{one as (Matrix 2 2)}
-->
(Matrix ((1 0)
         (0 1)))


{(+) : List}
-->
{zero : List}
-->
(List)

{(+) : Environment}
-->
{zero : Environment}
-->
<empty-environment>


(+) --> zero

{ zero : Environment }
--> <empty-environment>


....
-->
(Cons 0 (Cons 1 (take 2 (zip-with + xs (tail xs)))))
-->
#0=(Cons 0 (Cons 1 (take 2 (zip-with
                            +
                            #0#
                            (tail xs)))))
-->
#0=(Cons 0 (Cons 1 (take 2 (zip-with
                            +
                            #0#
                            (tail #0#)))))
-->
#0=(Cons 0 #1=(Cons 1 (take 2 (zip-with + #0# #1#))))
-->
(Cons 0 #1=(Cons 1 #2=(take 2 (Cons (+ 0 1) (zip-with + #1# #2#)))))
-->
(Cons 0 #1=(Cons 1 #2=(Cons (+ 0 1) (take 1 (zip-with + #1# #2#)))))
-->
(Cons 0
 (Cons 1
  #2=(Cons (+ 0 1)
      #3=(take 1 (Cons (+ 1 (+ 0 1)) (zip-with + #2# #3#))))))



(Rule Nil Nil)
(Rule (Cons $a $d) (Cons $a $d))
(Rule (take $n (Cons $a $d))
      (if (= $n 0)
          Nil
          (Cons $a (take (- $n 1) $d))))
(letrec (take 3 xs)
  [xs (cons 0 (cons 1 (zip-with + xs (tail xs))))])                
(take 3 xs)
(take 3 (Cons 0 (Cons 1 (zip-with + xs (tail xs)))))
(Cons 0 (take (- 3 1) (Cons 1 (zip-with + xs (tail xs)))))
(Cons 0 (take 2 (Cons 1 (zip-with + xs (tail xs)))))
....
(Cons 0 (Cons 1 (take 1 (zip-with + xs (tail xs)))))
(Cons 0 (Cons 1 (take 1 (Cons (+ 0 1) (zip-with + ....)))))



(get (Non-Negative $n))
(get (Positive $n))
(get (Array $x ...) $index)

(ref (Color/c $r $g $b $alpha) r)
--> $r

unsafe-real-Non-Negative-getter/{}
--> Non-Negative/n

(get/{} (Non-Negative/n $x))
--> $x

(new Non-Negative 5)
--> (Some (Non-Negative/n 5))

(Non-Negative $x)


(let (Cons (let x
             [x "b"])
           (let x
             [x "c"]))
  [x "a"])
-->
(Cons (let/a x/ab
        [x/ab "b"/a]/a)/a
      (let/a x/ac
        [x/ac "c"/a]/a)/a)/a
-->
(Cons x/ab x/ac)
-->
(Cons "b"/a "c"/a)
-->
(Cons x x)
-->
(Cons "b" "c")


X/{ab} ->
X/{ac} ->

X 
















































(begin = (* 2 result)
  (def result 5))
-->
(letrec result/{l}
  [result/{l} (* 2 result)/{rl}]
  [result/{rl} 5/{rl}])
-->
result/{l}
-->
(*/{rl} 2/{rl} result/{rl})/{rl}
-->
(*/{rl} 2/{rl} 5/{rl})/{rl}
--> ; (*/{} ...) --> number
10


(begin
  main = (* 2 x)
  (def x 5))
-->
(letrec result
  [result (* 2 x)]
  [x 5])
-->
result
-->
(* 2 x)
-->
(* 2 5)
-->
10

(Rule (begin main = $result
             (def $x $y) ...)
      (letrec result
        [result $result]
        [$x $y] ...))








(Cons 1 (Cons 2 Nil))

(Rule Nil Nil)
(Rule (Cons $a $d) (Cons $a $d))

(Rule (List $x ...)
      (List $x ...))






































(letrec x
  [x y]
  [y 10])
-->
x
-->
y
-->
10

(let/{} x/{}
  [x/{} y/{}]
  [y/{} 10/{}]/{})/{}
-->
(let/{} x/{1}
  [x/{1} y/{}]
  [y/{1} 10/{}]/{})/{}
-->
x/{1}
-->
y/{}

(let (Hello world!)
  [(Hello world!) 123])
-->
123









(let (* x 2)
  [x 5])
-->
(* x 2)
-->
(* 5 2)
-->
10
































`(1 2 ,(+ 2 3))
-->
`(1 2 5)

(Rule (with-token $T $body)
      (let (build-body (letrec token [token token]))
        [(build-body $T)
         (sequence $T $body)]))

(with-token $N
  (Env (Rule (try-new Non-Negative $x)
             (if ($x > 0)
                 (Some ($N $x))
                 None))
       (Rule (? (try-new Non-Negative $x))
             (format "Creates a non-negative value only if {} > 0"
                     $x))
       (Rule (unwrap ($N $x)) $x)
       (Rule (+ ($N $x) ...+)
             ($N (+ $x ...)))))

(let (build-env (letrec NN [NN NN]))
  [(build-env $NN)
   (sequence $NN
     (Env ))])


(let (build-env/l (letrec/l Non-Negative/ln
                    [Non-Negative/ln Non-Negative/ln]))
  [(build-env/l $Non-Negative/l)
   `(Env (Rule (new Non-Negative $x)
               .... (Some (,$Non-Negative/l $x))
               .... None))])
-->
(build-env/l (letrec/l Non-Negative/ln
               [Non-Negative/ln Non-Negative/ln]))
-->
`(Env (Rule (new Non-Negative $x)
               .... (Some (,$Non-Negative/l $x))
               .... None))
-->
`(Env (Rule (new Non-Negative $x)
               .... (Some (,(letrec/l Non-Negative/ln
                              [Non-Negative/ln Non-Negative/ln]) $x))
               .... None))
-->
`(Env (Rule (new Non-Negative $x)
               .... (Some (,Non-Negative/ln $x))
               .... None))
-->
`(Env (Rule (new Non-Negative $x)
               .... (Some (Non-Negative/ln $x))
               .... None))
-->
(Env (Rule (new Non-Negative $x)
               .... (Some (Non-Negative/ln $x))
               .... None))









(let (build-IO-env (letrec IO [IO IO]))
  [(build-IO-env $IO)
   `(Env (Rule read-line (,$IO io.read-line))
         (Rule (print-line $str) (,$IO (io.print-line $str)))
         (Rule (bind (,$IO $a) $f) (,$IO (io.bind (,$IO $a) $f)))
         (Rule (run (,$IO io.read-line)) builtins.read-line)
         (Rule (run (,$IO io.print-line $str)
               (builtins.print-line $str)))
         (Rule (run (,$IO (io.bind (,$IO $a) $f)))
               (let (sequence result ($f result))
                 [result (run (,$IO $a))])))])



















































(Rule `(let ,red [,pat ,res] ...)
      (with-scope l
        `(reduce ,(add-scope red l)
           (extend-env
            (Rule ,(add-scope pat l) ,res) ...))))

`(let (* 2 x)
   [x 5])
-->
(with-scope l
  `(reduce ,(add-scope `(* 2 x) l)
     (extend-env
      (Rule ,(add-scope `x l) 5))))
-->
`(reduce ,(add-scope `(* 2 x) l)
   (extend-env
    (Rule ,(add-scope `x l) 5)))
-->
`(reduce (* 2 x)
   (extend-env
    (Rule x 5)))








(Rule (letrec $red [$pat $res] ...)
      (reduce $red
        (extend-env
         (Rule $pat $res) ...)))

((Rule $IO
       (let (Env io:print-line)
         [io:print-line (Rule (print-line $str)
                              ($IO (builtins.print-line $str)))]))
 (letrec IO [IO IO]))


(and False `(or True False))
-->
(and False `True)
-->
(and False True)
-->
False

`<T> is defined as <F>, where <F> is the fixed-point term that <T>
reduces to. If <T> fails to reduce to a fixed-point, `<T> is defined
as 'undefined' instead.



(Rule `(with-scope $s ,$body)
      (reduce $body
        (Env (Rule $s ``unique-scope))))


unique-scope --> <N>, where <N> is a scope unique to the
environment. e.g.,

  unique-scope
  --> 0

  `unique-scope
  -->
  `1

(Rule `(with-scope $s ,$body)
      (reduce $body
        (Env (Rule $s ``unique-scope))))

(Rule (let $red [$pat $res] ...)
      `(with-scope S
         ,(reduce `(scope-add ,$red S)
            (Env (Rule `(scope-add ,$pat S) $res) ...))))
(let (* x 2)
  [x 5])
-->
`(with-scope S
   ,(reduce `(scope-add ,(* x 2) S)
      (Env (Rule `(scope-add ,x S) 5))))
-->
(reduce (reduce `(scope-add ,(* x 2) S)
          (Env (Rule `(scope-add ,x S) 5)))
  (Env (Rule `S ``unique-scope)))
-->
(reduce (reduce `(scope-add ,(* x 2) S)
          (Env (Rule `(scope-add ,x S) 5)))
  (Env (Rule `S `0)))
-->
(reduce `(scope-add ,(* x 2) S)
  (Env (Rule `(scope-add ,x S) 5)))
-->
(reduce `(scope-add ,(* x 2) 0)
  (Env (Rule `(scope-add ,x S) 5)))
-->
(reduce (* x 2)/0
  (Env (Rule `(scope-add ,x S) 5)))
-->
(reduce (* x 2)/0
  (Env (Rule x/0 5)))
-->
(* x 2)/0
-->
(* 5 2)/0
-->
10


(Rule (let $red [$pat $res] ...)
      (with-scope S
        (reduce (insert $red S)
          (Env (Rule (insert $pat S)
                     $res)
               ...))))

(let (* result 2)      ; (let (* result 2)
  [result (+' 3 4 5)]) ;   [result (+ 3 4 5)])
-->                    ; -->
(let (* result 2)      ; (* result 2)
  [result 12])         ; -->
-->                    ; (* (+ 3 4 5) 2)
(* result 2)           ; -->
-->                    ; (* 12 2)
(* 12 2)               ; -->
-->                    ; 24
24                     ;

(let (* result 2)
  [result `(+ 3 4 5)])
-->
(* result 2)
-->






(Rule (let $red [$pat $res] ...)
      (reduce `$red
        (Env (Rule `$pat $res) ...)))h


(reduce-partially <T> <E>)

  (Rule (let $red [$pat $res] ...)
        (scope ls
          (reduce (scope-set-add ls $red)
            (Env (Rule (scope-set-add ls $pat) $res) ...))))

It seems like sometimes there's a need to act on a term recursively
and eagerly. 'Scope', for example, is something that would need to
reduce to its argument but with all parts of it having a new unique
scope placed on each part---except for the 'unscope' parts, although
I'm not sure about that.

It's also not clear how to scope 'scope' itself. What should the
following do?

  (scope (scope (unscope x)))

Which scope is unscoped? Both? One? Either? Error? Neither? Loop? The
problem is not eliminated if we give the scopes names:

  (scope s (scope s (unscope s x)))

Because we could just give them the same names. I think what should
happen is that the use of 's' in the unscope should be the inner 's',
as it has 'shadowed' the outside one.

  (scope <id> <T>) - puts a unique scope on all parts of <T>, except
  for those wrapped in (unscope <id> <Q>), except that 'unscope' only
  applies to the outer layer; the inner parts of <Q> still get scope
  <id> added.

(Rule <pattern> <result>)

  Defined with the following rules:

(reduce-in-environment <T> <E>)

  Attempts to reduce <T> to a fixed-point using the rules in <E>. If
  reduction fails, reduces to undefined.

current-environment

  Reduces to the builtin environment.

(reduce <T>)

  Defined with the following rule:

    (Rule (reduce $term)
          (reduce-in-environment $term current-environment))

(letrec <reduction> [<pattern> <result>] ...)

  Defined with the following rule:

    (Rule (letrec $red [$pat $res] ...)
          (reduce-in-environment $red
            (+ current-environment
               (Env (Rule $pat $res) ...))))

(let <reduction> [<pattern> <result>] ...)

  Defined with the following rule:

    (Rule (let $red [$pat $res] ...)
          (reduce-in-environment $red
            (+ current-environment
               (Env (Rule $pat (unscope $res)) ...))))


    (Rule (let $red [$pat $res] ...)
          (scope ls
            (reduce-in-environment $red
              (+ current-environment
                 (Env (Rule $pat (unscope ls $res)))))))

  (scope
    (scope
      (unscope x)))

  (scope ls
    (scope ls
      (unscope ls x)))
  --> ???

  (Rule (letrec $red [$pat $res] ...)
    `(with-env $red
       (Env (Rule $pat $res) ...)))

  (reduce-in-environment <T> <E>)

  (Rule (letrec $red [$pat $res])
    `(reduce-in-environment $red
       (+ current-environment
          (Env (Rule $pat $res) ...))))

  (letrec current-environment
    [current-environment (Env)])
  -->
  (reduce-in-environment current-environment_a
    (+ current-environment
       (Env (Rule current-environment_a (Env_a)_a))))
  -->
  (reduce-in-environment current-environment_a
    (+ #0=(Env (Rule current-environment #0#)
               ....)
       (Env (Rule current-environment_a (Env_a)_a))))
  -->
  (reduce-in-environment current-environment_a
    (Env (Rule current-environment_a (Env_a)_a)
         (Rule current-environment #0#)
         ....))
  











Current things I think need to be primitives

  - Rule

    - Does 'Rule' add a scope to the substitution of $-ids in its
      result? - can't with all of them for implementing 'let'. OK for
      implementing 'letrec'. Maybe problematic in other places? Could
      fix this by having it not add any scope and then add scopes
      manually with (scope ....) and (unscope <T>). 

  - Env

  - with-env

    - doesn't make much sense if the rules introduced don't add a
      scope on ids.

  - (replace <T> [<pat> <res>]) -- eagerly replaces occurrences of
    <pat> with <res> in <T>.

  - scope (`)

    - alternative: (with-scope $ID ....) binds $ID to scope token, any
      occurrence of ($ID <T>) inside of the with-scope adds scope $ID
      to <T> during reduction of the (with-scope ....).

      Maybe even

       (with-scope adds-recursively IO-rec
                   adds-single IO-1
                   removes-recursively IO-rem-rec
                   removes-single IO-rem-1
         ....)

       (with-scope (Rule (let ))
         [+ let+ let++]
         [- let- let--])

  - unscope (,)

  - unscope-recursive (,@)

  - sequence

  - identical

Definitions:

[Rule] [$]

  Informal description:

    (Rule <pattern> <result>)

  The above term creates a 'rule'. It's a fixed-point term that can be
  the result of a program. It doesn't do anything by itself. For the
  rule to be made 'available', it has to be put in an environment,
  with 'Env', and the resulting environment must then be selected,
  with 'with-env'. More on that later.

    (Rule x 10)

  This rule, when made available in the environment (I will elide this
  remark from now on) is said to be 'applicable' to some terms and not
  to some other terms. Here are some terms to which the rule is
  applicable, or 'applies':

    x ; in the same scope as the 'x' from the (Rule ....) earlier

    x ; but in a scope that is more deeply nested than the previous
      ; 'x' (but still in the same scope as the other 'x').

  Here are some terms to which the rule is not applicable:

    x       ; but in a scope that is not inside of the scope that the
            ; 'x' in the (Rule ....) term comes from.

    y       ; 'y' isn't 'x', so the rule doesn't apply

    (+ 2 3) ; neither is this term 'x'

    x x     ; the 'x' only matches one 'x', not multiple

  The first part of a term is called its pattern, and the latter part
  its result. In the previous example, the 'x' is the pattern and the
  '10' is the result. If the rule applies, the term to which it
  applies is replaced with the result:

    x
    --> ; read the arrow as 'reduces to under a certain rule'
    10

  It is possible to make more complicated rules which are applicable
  to more than just an identifier:

    (Rule (a b (c d)) ((c d) a b))

  is a rule that reduces (a b (c d)) to ((c d) a b), assuming that in
  each part of the pattern, the scoping rules apply (e.g., the term's
  'a' must be at least as nested inside the same scope as the
  pattern's 'a', and the parentheses (....) around the 'c' and 'd'
  must also have come from a scope that is at least as nested as the
  corresponding parentheses in the pattern).

  Patterns can be written that match zero or more of some term by
  using '...':

    (Rule (mult x ...) (* x ...))

  is a rule that when applied can make the following reductions occur:

    (mult)             --> (*)
    (mult x)           --> (* x)
    (mult x x)         --> (* x x)
    (mult x x x x x x) --> (* x x x x x x)

  To match one or more instead of zero or more, use '...+'
  instead. So, (Rule (mult x ...+) (* x ...)) would be applicable to
  all terms above except for (mult). Note that adding the '+' after
  the '...' in the result is not necessary.

  It is often useful to write a rule where part of the pattern is
  applicable to any term.

    (Rule (identity $x) $x)

  is a rule that does the following:

    (identity 123)
    --> 123
    
    (identity (Hello world))
    --> (Hello world)

    (identity (identity Goodbye))
    --> (identity Goodbye)
    --> Goodbye

  As many of these dollar-sign-identifiers can appear in a pattern as
  desired. They all must have unique names, and it is possible to not
  use them in the result if discarding a part of the pattern is
  necessary:

    (Rule (ignored $ignored) "Goodbye.")

[scope] [unscope] [unscope-recursive]
[`]     [,]       [,@]

  (Rule (let $d [$pat $res] ...)
    `(with-env $d
       (Env (Rule $pat ,$res) ...)))

  (Rule (letrec $d [$pat $res])
    `(with-env $d
       (Env (Rule $pat $res) ...)))

  (Scoped-Env (IO)
    (Rule read-line (IO builtins.read-line))
    (Rule (print-line $str) (IO (builtins.print-line $str)))
    (Rule (bind (IO $a)))

  `(,Env ,(,Rule ,read-line ,(IO ,builtins.read-line))
         ,(,Rule ,(,print-line ,$s) ,(IO ,(,builtins.print-line ,$s)))
         ,(,Rule ,(,bind ,(IO ,$a) ,$f) ,(,$f `,$a))
         ,(,Rule ,(,run ,(IO ,$a)) `,$a))

  (let (extract (print-line "Hello, world!"))
    [(extract (IO $a)) $a])
  -->
  (extract (print-line "Hello, world!"))
  -->
  (extract (IO_1 (builtins.read-line "Hello, world!")))
  -->
  

  The $x in the result is not quite the same as the $x in the
  pattern. The difference is that when the $x in the result is
  replaced with a term <T> (like 123 or (Hello world) in the example),
  a unique scope is added to <T>'s scope-set. So, the (Hello world) we
  got out of applying the rule has a scope added to the parentheses,
  the Hello, and the world. This unique scope added is the same for
  all such dollar sign identifiers. That is, if we have the following
  rule:
  
    (Rule ($x + $y) (+ $x $y))

  then the terms that replace $x and $y when the rule is applied will
  both have the same, unique scope added to both of their
  scope-sets. The usage of 'unique' here means that no other term yet
  encountered has had the scope in its scope-set, and that no future
  application of a rule (perhaps even this same rule) will add the
  same scope. All applications of rules add unique scopes to their
  dollar-sign-replacement-terms. Note that if the following two rules
  are available in the environment:

    (Rule (step 1 = $x) (step 2 = $x))
    (Rule (step 2 = $x) (finished $x))

  then the following reduction could occur:

    (step 1 = 123)
    --> (step 2 = 123_a)  ; the _a represents the unique scope added
    --> (finished 123_ab) ; other rule added scope b

  The second rule is applicable to both 123 and 123_a because the rule
  was created in the top level scope, of which scope 'a' is inside
  of. Because 123_a is inside of the scope that the corresponding part
  in the pattern is in, the rule applies.

  Because rules are terms, and results of rules are terms, rules may
  result in other rules:

    (Rule (letrec $reduction [$pat $res] ...)
          (with-env $reduction
            (Env (Rule $pat $res) ...)))

  With this rule in our environment, the following reduction could
  occur:

    (letrec x
      [x y]
      [y 10])
    -->  ; Call the scope added by this 'letrec' 1.
    (with-env x_1
      (Env (Rule x_1 y_1)
           (Rule y_1 10_1)))
    -->  ; Apply the builtin with-env term, which makes the (Env ....)
         ; rules available before reducing to x_1.
    x_1
    -->  ; Apply the rule (Rule x_1 y_1) added by with-env.
    y_1
    -->  ; Apply the rule (Rule y_1 10_1) added by with-env.
    10_1 ; OK: reduction complete.

  Notice that when the rule applies it replaces *all* occurrences of
  matching dollar-sign-identifiers, including those which are inside
  of other (Rule ....) terms in the result. If there is a
  dollar-sign-identifier in the result that does not correspond to one
  in the pattern then it is left as it is.

  Sometimes it is undesirable to have the unique scope applied to a
  dollar-sign-replacement in the result. To remove such a scope from
  the dollar-sign-identifier $<ID>, use (~unscope $<ID>). This stops
  the scope from being added when the rule is applied:

    (Rule (let $reduction [$pat $res] ...)
          (with-env $reduction
            (Env (Rule $pat (~unscope $res)) ...)))

  With the above rule available, the following reduction could occur:

    (let (let x
           [x x])
      [x 10])
    --> ; outer 'let' adds scope '1'
    (with-env (let_1 x_1
                [x_1 x_1]_1)_1
      (Env (Rule x_1 10))) ; notice that 10 didn't get _1.
    -->
    (let_1 x_1
      [x_1 x_1]_1)_1
    --> ; Our 'let' rule is defined in the top level scope-set,
        ; {}. Because the scope-set {} is a non-strict subset of
        ; {a}, the rule applies. Call the scope added by the second
        ; 'let' '2'. 
    (with-env x_12
      (Env (Rule x_12 x_1))) ; notice that x_1 didn't get 2.
    -->
    x_12
    --> ; Apply rule (Rule x_12 x_1) added by with-env.
    x_1
    --> ; Apply rule (Rule x_1 10) added by with-env.
    10  ; OK: reduction complete.

  Sometimes




    (Rule (let $d [$p $r] ...)
      `(with-env $d
         (Env (Rule $p ,$r))))

    (Rule (let $d [$p $r] ...)
      `(with-env $d
         (Env (Rule $p ,$r))))
    (Rule (let $d [$p $r] ...)
      `(with-env $d
         (Env (Rule $p $r))))


    (Rule (letrec $d [$p $r] ...)
          (with-env $d
            (Env (Rule $p $r) ...)))
    (letrec x
      [x y]
      [y 10])
    -->
    (with-env x_1
      (Env (Rule x_1 y_1)
           (Rule y_1 10_1)))
    -->
    x_1
    -->
    y_1
    -->
    10_1

    (Rule (let $d [$p $r] ...)
          (with-env $d
            (Env (Rule $p (unscope $r)) ...))))

    (let x
      [x y]
      [y 10])
    -->
    (with-env x_1
      (Env (Rule x_1 y)
           (Rule y_1 10)))
    -->
    x_1
    -->
    y
    --> ERROR: no reduction. (good, the expected result)

   (let (let x [x x])
     [x 10])
   -->
   (with-env (let_1 x_1 [x_1 x_1]_1)_1
     (Env (Rule x_1 10)))
   -->
   (let_1 x_1 [x_1 x_1]_1)_1
   -->
   (with-env x_12
     (Env (Rule x_12 x_1)))
   -->
   x_12
   -->
   x_1
   -->
   10

   (Rule (begin main = $effect
                (def $p $r) ...)
         (letrec (seq effect 0 1)
           [effect $effect]
           [$p $r] ...))

   (begin main = effect
          (def effect 10))
   -->
   (letrec (seq effect 0 1)
     [effect effect_1]
     [effect_1 10_1])
   -->
   (with-env (seq_2 effect_2 0_2 1_2)_2
     (Env (Rule effect_2 effect_12)
          (Rule effect_12 10_12)))
   -->
   (seq_2 effect_2 0_2 1_2)
   -->
   (seq_2 effect_12 0_2 1_2)
   -->
   (seq_2 10_12 0_2 1_2)
   -->
   0_2






   (begin export = io:env
     (def io:env
       (scope
         (let (Env io:run io:print-line)
           [io:run (Rule (IO $a) $a)]
           [io:print-line
            (Rule (unscope (print-line $a))
                  (IO (builtins.print-line (unscope $a))))]))))

   (begin export = io:env
     (def io:env
       `(let (Env io:run io:print-line)
          [io:run (Rule (IO $a) $a)]
          [io:print-line
            (Rule ,(print-line $a)
                  (IO (,builtins.print-line ,$a)))])))







   (Rule (begin export = $e
                (def $p $r) ...)
         (let $e
           [$p $r] ...))
   (begin export = io:env
     (def io:env
       (scope
         (let (Env io:run io:print-line)
           [io:run (Rule (IO $a) $a)]
           [io:print-line
            (Rule (unscope (print-line $a))
                  (IO (builtins.print-line (unscope $a))))]))))
   -->
   (let io:env_1
     [io_env_1
      (scope
        (let (Env io:run io:print-line)
          [io:run (Rule (IO $a) $a)]
          [io:print-line
           (Rule (unscope (print-line $a))
                 (IO (builtins.print-line (unscope $a))))]))])
   -->
   (with-env io:env_12
    (Env
     (Rule
      io:env_12
      (scope
        (let (Env io:run io:print-line)
          [io:run (Rule (IO $a) $a)]
          [io:print-line
           (Rule (unscope (print-line $a))
                 (IO (builtins.print-line (unscope $a))))])))))
    -->
    io:env_12
    -->
    (scope
      (let (Env io:run io:print-line)
        [io:run (Rule (IO $a) $a)]
        [io:print-line
         (Rule (unscope (print-line $a))
               (IO (builtins.print-line (unscope $a))))]))
    -->
    (let_3 (Env_3 io:run_3 io:print-line_3)_3
      [io:run_3 (Rule_3 (IO_3 $a_3)_3 $a_3)_3]_3
      [io:print-line_3
       (Rule_3 (print-line $a)
               (IO_3 (builtins.print-line_3 $a)_3)_3)_3]_3)_3
    -->
    (with-env (Env_34 io:run_34 io:print-line_34)_34
      (Env (Rule io:run_34
                 (Rule_3 (IO_3 $a_3)_3 $a_3)_3)
           (Rule io:print-line_34
                 (Rule_3 (print-line $a)
                         (IO_3 (builtins.print-line_3 $a)_3)_3)_3)))
    -->
    (Env_34 io:run_34 io:print-line_34)_34
    -->
    (Env_34
      (Rule_3 (IO_3 $a_3) $a_3)_3
      io:print-line_34)
    -->
    (Env_34
      (Rule_3 (IO_3 $a_3)_3 $a_3)_3
      (Rule_3 (print-line $a)
              (IO_3 (builtins.print-line_3 $a)_3)_3)_3)
    --> ; OK: reduction complete.






    (begin main = (extract (print-line "Hello, world!"))
      (def (extract (IO $a)) $a))
    -->
    (letrec (seq effect 0 1)
      [effect (extract_5 (print-line_5 "Hello, world!"_5)_5)_5]
      [(extract_5 (IO_5 $a_5)_5)_5 $a_5])
    -->
    (with-env (seq_6 effect_6 0_6 1_6)_6
      (Env (Rule effect_6
                 (extract_56
                  (print-line_56 "Hello, world!"_56)_56)_56)
           (Rule (extract_56 (IO_56 $a_56)_56)_56 $a_56)))
    -->
    (seq_6 effect_6 0_6 1_6)_6
    -->
    (seq_6 (extract_56 (print-line_56 "Hello, world!"_56)_56)_56
           0_6
           1_6)_6
    -->
    (seq_6 (extract_56 (print-line_56 "Hello, world!"_56)_56)_56
           0_6
           1_6)_6
    -->
    (seq_6 (extract_56 (IO_3 (builtins.print-line_3 "Hello, world!"_56)_3)_3)_56
           0_6
           1_6)_6
    --> ERROR: irreducible term.
    



    (Env_34
      (Rule_3 (IO_3 $a_3)_3 $a_3)_3
      (Rule_3 (bind (IO_3 $a_3)_3 $f) ($f $a_3)_3)
      (Rule_3 (print-line $a)
              (IO_3 (builtins.print-line_3 $a)_3)_3)_3)



    (Rule (r= $r) $r)

    (r= (Rule (id $x) $x))
    -->
    (Rule_u (id_u $x_u)_u $x)_u

    (r= (r= (Rule (id $x) $x)))
    -->
    (r=_a (Rule_a (id_a $x_a)_a $x_a)_a)_a
    -->
    (Rule_ab (id_ab $x_ab)_ab $x_ab)_ab







  For terms <pattern> and <result>, the term:

    (Rule <pattern> <result>)

  reduces to a fixed-point representing a rule. The rule matches all
  terms <T> under the following conditions:

    - <pattern-$ooo> and <T> are isomorphic.

      - Let <pattern-$> be <pattern> except that all occurrences of ($
        <Q>), for some term <Q>, have been replaced with their
        isomorphic counterpart in <T>, if such a term exists.

      - Let <pattern-$ooo> be <pattern-$> except that all occurrences
        of '<Q> ...' have been replaced with zero-or-more of their
        isomorphic counterparts in <T>, and all occurrences of '<Q>
        ...+' have been replaced with one-or-more of their isomorphic
        counterparts in <T>.

    - For each sub-term <S> of <T>, the scope-set of the isomorphic
      sub-term of <S> in <pattern> is a non-strict subset of the
      scope-set of <S>.

  If the rule is applied to <T>, it results in the term <T-$ooo>,
  with:

    - Let <T-$> be <T> except that all occurrences of ($ <Q>) [which
      got replaced earlier with the corresponding isomorphic term
      <T$>] are replaced with <T$>_+{u}, where 'u' is a unique scope.

    - Let <T-$ooo> be ....


  identical to <pattern> to <result>, except for the following
  qualification:

    - All instances of ($ <I>) in <pattern> match any term.

    - All instances of ($ <I>)

[scope] [unscope]

  For terms <T> and identifiers <I>, the term:

    (scope $<I> <T>)

  reduces to <T> with the following qualifications:

    1. For all subterms <Q> of <T>, <Q> is reduced to
       <Q>_+{unique-scope}.

    1. For all subterms <Q> of <T>, all occurrences of (unquote <S>
       <Q>) are reduced to <Q>.

    2. For all subterms <Q> of <T> that were not reduced by (1), <Q>
       is reduced to <Q>_+{unique-scope}: the term that is just like
       <Q> except a unique scope has been added to its scope-set.

  The scope and unscope terms can be used in conjunction with Env,
  Rule, and with-environment to define 'let' and 'letrec':

    (Rule (letrec $red [$pat $res] ...)
          (scope $_
            (with-environment $red
              (Environment (Rule $pat $res) ...))))
    (Rule (let $red [$pat $res] ...)
          (scope $let
            (with-environment $red
              (Environment (Rule $pat (unscope $let $res))))))

  We might then use them like so:

    (let_ (+_ x_ y_)_
      [x_ 10_]_
      [y_ 20_]_)_
    -->
    (scope_ $let_
      (with-environment_ (+_ x_ y_)_
        (Environment_ (Rule_ x_ (unscope_ $let_ 10_)_)_
                      (Rule_ y_ (unscope_ $let_ 20_)_)_)_)_)_
    -->
    (with-environment_s (+_s x_s y_s)_s
      (Environment_s (Rule_s x_s 10_)
                     (Rule_s y_s 20_)_s)_s)_s
    -->
    (+_s x_s y_s)_s
    -->
    (+_s 10_ y_s)_s
    -->
    (+_s 10_ 20_)_s
    -->
    30_


(Rule (*2-with-rules $red [$pat $res] ...)
      (let (* number $red)
        [number 2]
        [$pat $res] ...))
(*2-with-rules number [number 100])
-->
(let (* number number)
  [number 2]
  [number 100]) ; ERROR: non-deterministic environment

(*2-with-rules_ number_ [number_ 100_]_)_
-->
(let_ (*_ number_ number_r)
  [number_ 2_]_
  [number_r 100]_)_ ; OK.

(Rule (letrec ($ red) [($ pat) ($ res)] ...)
      (scope
        (with-environment ($ red)
          (Environment (Rule ($ pat) ($ res)) ...))))


[Rule]

  A fixed-point term representing a rule-set containing either exactly
  one or an infinite set of rules. For all terms <pattern> and
  <result>, the term ...

    (Rule <pattern> <result>)

  ... creates such a rule-set. Call this the 'rule-term'. If, for all
  terms <T>, there are no occurrences of the terms ($ <T>) or $ inside
  <pattern> or <result>, then the rule-term represents a rule-set of
  exactly one rule, otherwise, it represents an infinitely-sized
  rule-set. Call the former case the 'single-rule-term', and the
  latter the 'multi-rule-term'.

  For all scope-sets S and E, a single-rule-term with pattern
  <pattern>_S, is applicable to all terms <pattern>_S+E

  












OLD WORK BELOW HERE:

FIXME:

  1. get rid of x/y to mean WITH in some places when you said it means
     HAS SCOPE SET!

  2. Rule, Env defs?

Notation:

  1. Y/{Z} means that the scope-set of term Y is a set containing only
     one scope, Z.

  2. Y/X means that the term Y has scope-set X.

  3. Y/X+{Z} means that term Y has scope-set (X union {Z}) for some
     scope Z.

  4. 'next scope S' is a never-before-seen scope, i.e., no term has
     ever before had S in its scope-set.

  5. If an identifier is used without a scope-set (like 'X' instead of
     'X/S'), then the scope-set is meant to be inferred from the
     context. If a definition requires that a rule be placed in the
     environment then---unless stated otherwise---the enclosing
     scope-set is the top-level empty one, {}.

  6. {unique-scope} is a unique scope.

FIXME: remove the following?

 ;;; Definition of [noreduce-scope]: A single, never-before-seen
 ;;; scope. Because the only way to introduce scopes on terms is through
 ;;; 'let' and 'letrec', and because the scopes introduced by those terms
 ;;; are always never-before-seen-scopes, no term (outside of the ones
 ;;; specified here) can ever have this noreduce-scope in their
 ;;; scope-set. The purpose of the noreduce-scope is to make the term
 ;;; (no-reduce/{noreduce-scope} $) irreducible. Because it is impossible
 ;;; to apply the noreduce-scope to any term in user code, it's impossible
 ;;; to write a rule whose pattern contains
 ;;; no-reduce/{[no-reduce-scope]}. Because there is no rule specified here
 ;;; (on purpose) that makes (noreduce/{noreduce-scope} $) a fixed-point,
 ;;; or any rule that re-writes it to something reducible to one, it cannot
 ;;; be reduced to a fixed-point. Thus, if that term ever becomes a redex
 ;;; in real code, the program will crash. This is occasionally useful
 ;;; (more will be said about this later).

Definitions [env], [rule]:

  For any two terms <pattern>/PS and <result>/RS, the following creates
  a single rule ...

    (Rule <pattern> <result>)

  ... if and only if <pattern> and <result> do not contain any
  identifiers beginning with '$', or '$' itself (with no characters
  following it) ['$' may appear at the end or middle of an identifier
  with >=1 characters, but not at the beginning]. This rule is
  applicable to all terms <T>/PS+?, and, if applied, reduces to
  <result>/RS.

  For any two terms <$pattern>/PS and <$result>/RS the following
  creates an infinite set of rules ...

    (Rule <$pattern>/PS <$result>/RS+$)

  ... if and only if (for every dollar-sign-identifier D in
  <$result>/RS, D is in <$pattern>/PS).


Definition [rule$]:

    For an environment E, Let APP be a scope called the 'rule
    application scope' unique to E. Then for all terms <$pattern>/PS
    and <$result>/RS, and for every dollar-sign-identifier <D>/IDS in
    <$result>/RS, ...

      (Rule <$pattern>/PS <$result>/RS)

    ... defines an infinite set of rules, Rules, where if a rule (Rule
    <actual-pattern>/APS <actual-result>/ARS) is a member of Rules,
    then 

then if <D>/IDS is in <$pattern>/PS, then
    for every term <U>/US, let <$result-non-dollar>/RS be <$result>/RS
    except that all occurrences of <D>/IDS have been replaced with
    <U>/US+{APP}, and let <$pattern-non-dollar>/PS be <$pattern>/PS
    except that all occurrences of <D>/IDS have been replaced with
    <U>/US, where APP is a unique scope called the 'rule application
    scope'.

Then for
    every dollar-sign-identifier D/IDS+{A}, and every term <U>, let
    <$result->/RS ...

      (Rule <$pattern>/PS <$result>/RS)

    ... creates an infinite set of rules

  The following form creates an environment:

    (Env <rule> ...)

  if and only if (each <rule> reduces to a 'rule-series' AND every
  rule in every 'rule-series' are pairwise-deterministic). For any
  terms <pattern>/PS and <result>/RS, 

    (Rule <pattern>/PS <result>/RS+$)

  creates a rule-series, which is a fixed-point, which is to say that
  it is a 'value', i.e., something that can be the result of a
  program. Note that while <pattern> does not get any new scopes,
  <result> does: a unique 'pattern application scope'.

  If neither <pattern> nor <result> contain a dollar-sign-identifier,
  (e.g., $foo, $blahblahblah, $etc), then the rule-series has only one
  element: a single rule. For example,

    (Rule (x y z) (y z x))
    ; annotated with scopes below
    (Rule (x/XS y/YS z/ZS)/PS (y/YS z/ZS x/XS)/RS)

  is a single rule. It is applicable to an infinite set of terms:

    (x y z)
    ; annotated with scopes below
    (x/XS+? y/YS+? z/ZS+?)/PS+?

  ... where '<term>/<scope-set>+?' specifies any term identical to
  <term> whose scope-set is a non-strict superset of <scope-set>. This
  is to say that as long as the 'x', 'y', and 'z' (and the
  parentheses) come from at least as nested a scope as XS, YS, ZS, and
  PS respectively, the rule is applicable.

  In a given environment, the rule that is applied to the term is the
  one whose PS (the scope-set on the outer parentheses of the
  <pattern>) is 'closest' to the scope-set on the outer parentheses on
  the term (PS+?), where 'closest' involves a non-strict subset
  ordering of rules, from the one with the least elements of PS to the
  most elements. The one with the most is the rule that applies. Note:
  the definition of Env requires that the rules are
  pairwise-deterministic; this rules out the case that there are two
  rules which have the same pattern but different result AND have the
  same scope sets on 'pattern'.

  If the rule-form contains at least one 'dollar-sign-identifier' then
  it specifies an infinitely-sized rule-series. For example,

    (Rule (unwrap (Some $x)) $x)

  is an abbreviation for the following infinite series of rules:

    (Rule (unwrap (Some 0)) 0)
    (Rule (unwrap (Some 1)) 1)
    ....
    (Rule (unwrap (Some 99999999572)) 99999999572)
    ....
    (Rule (unwrap
           (Some (((((((("Hello, world!"))))) "Goodbye, world!")))))
          (((((((("Hello, world!"))))) "Goodbye, world!"))))
    ....
    (Rule (unwrap (Some undefined))
    .... etc. .....

  That rule matches any term that is placed in the position of $x, as
  long as all parts of that term have scope-sets that are non-strict
  supersets of

Definition [only-in-this-order]:

  For our purposes here, <rule>/PS/RS is a term that reduces to a rule
  whose pattern scope is PS and whose result scope is RS. The
  following term:

    (only-in-this-order <rule> ...+)

  reduces to an environment containing <rule>/

    (let [y 10]
      (let [(id y) y]
        (id y))) --> 10

    (let [y 10]
      (let [(id x) y]
        (id x))) --> 10

    (let [y 10]
      (let [(id x) y]
        (id y))) --> ERROR, no reduction for (id y).

    (let [y 10]
      (let [(id $x) y])
        (id z)) --> 10

    (let [y 10]
      (let [(id $x) (+ 1 x)]
        (id y))) --> 11

    (let [y 10]
      (let [(id $x) (+ 1 x)]
        (id z))) --> ERROR, no reduction for (+ 1 z).

    (let [(x y) 10]
      ((let x) (let y)))
    --> ((let x) (let y))
    --> (x (let y))
    --> (x y)
    --> 10

    (let [(x y) 10]
      ((let [z y] x) z))
    --> ((let [z y] x) z)
    --> (x z) --> ERROR, no reduction for (x z)


      ; io.lang

      (let [io:run
            (Env
             (freeze-pattern
              [(run (IO $x)) $x])
             (freeze-pattern
              [(run (IO $first $others ...+))
               (sequence $first
                         (IO $others ...)
                         undefined)]))]
           [io:println
            (Env
             (freeze-result
              [(println $x)
               (IO (builtins.impure.println $x))]))]
        (+ io:run io:println)

      ; now, let's uses these:

        main = (run (println "Hello, world!"))
        -->
        (let [side-effects (run (println "Hello, world!"))]
          (sequence side-effects 0 1))
        -->
        (sequence side-effects 0 1)
        -->
        (sequence (run (println "Hello, world!")) 0 1)
        --> ; Hello, world! is printed
        0

      ; but since the pattern of io:run is frozen, we can't use it in
      ; a nested scope:

        main = (let [y (run read-line)]
                    [z (run read-line)]
                 (+ y z))

Definition [freeze-at-or-below]: (freeze-at-or-below <T>/TS (Rule
$pattern/PS $result)), reduces to a rule whose pattern only matches
terms whose scope-set is a non-strict superset of PS AND a non-strict
subset of TS.

  For example, assume we are in an environment with the following
  rules:

    (freeze-at-or-below IO (Rule (run IO $x)
                                 (run:unsafe IO $x)))
    (Rule (run:unsafe IO (IO $x)) $x)
    (Rule (run:unsafe IO (IO $first $rest ...+))
          (sequence $first (run:unsafe IO $rest ...)))

  Then ...

    main = (perform-IO (bind read-line print-line))
    -->
    (sequence (unsafe-perform-IO (bind read-line print-line))
    -->
    (sequence (unsafe-perform-IO (bind read-line print-line)) 0 1)
    -->
    (sequence (unsafe-perform-IO (bind read-line print-line)) 0 1)
    --> ; "Hello, world!\n" added to stdin
    (sequence
     (unsafe-perform-IO (bind (IO "Hello, world!") print-line)) 0 1)
    --> 
    (sequence (unsafe-perform-IO (print-line "Hello, world!")) 0 1)
    -->
    (sequence (unsafe-perform-IO (IO ())) 0 1)
    -->
    (sequence () 0 1)

  But ...

    main = (perform-IO (println (sneaky-id "Hello, world!")))
    (def (sneaky-id $x)
      (sequence (perform-IO (print-line "Surprise!"))
                $x
                undefined))
    -->
    (letrec [(sneaky-id $x)
             (sequence (perform-IO (print-line "Surprise!"))
                       $x
                       undefined)]
      (sequence
       (perform-IO (println (sneaky-id "Hello, world!")))
       0
       1))
    (sequence
     (perform-IO (println (sneaky-id "Hello, world!")))
     (letrec [sneaky)         
     )
Definition [freeze-at-or-above]: (freeze-at-or-above <T>/)

Definition [let]:

  ; In environment E with next scope S,
  (let [<pattern>/SP <result>/SR]
    <body>/SB)
  --> <body>/SB+{S} ; In environment E extended with (Rule
                    ; <pattern>/SP+{S} <result>/SR) but only if the
                    ; new environment is defined, i.e., only the new
                    ; rule is pairwise-deterministic with the rules
                    ; of E.

  'let' and 'letrec' can be used to create 'containers' which can't be
  unwrapped, except by special privileged code. For example, consider
  the following term which defines '(new Secure <v>)', which 

    (export s:new s:bind)

    (def s:new
      (Rule (new Secure $v)
      
        ; Notice that the 'Secure' in the pattern of this rule above
        ; is the SAME 'Secure' as the 'Secure' in the top-level
        ; environment. This is not the case with
        ; 'Secure:secret-scope', as we will learn below:
      
        (Secure:secret-scope $v)))

    (def s:bind
      (Rule (bind (Secure:secret-scope $v) $f)
        ($f $v)))

    (def Secure:secret-scope

      ; Create a fixed-point term, 'inner-scope', that has an extra,
      ; unique scope on it (because it is defined inside of a
      ; 'letrec'). We could have tried to define 'inner-scope' inside
      ; of a 'let', and this would indeed put a new, unique, scope on
      ; 'inner-scope', but because that new unique scope wouldn't be
      ; applied to the RHS of '[inner-scope inner-scope]', the body of
      ; the 'let' would reduce to the RHS 'inner-scope' (e.g., the
      ; 'inner-scope' in the top-level environment. But if that were
      ; the case we would be able to pattern match on it in code that
      ; was run in the environment that this library reduces to, hence
      ; the need for 'letrec'). Why can't we match on the 'letrec'
      ; version? Because a rule's pattern only matches if the
      ; pattern's scope-set is a non-strict subset of the term's
      ; scope-set. Since no rule exists that reduces to THIS
      ; 'inner-scope' in the environment that this library reduces to,
      ; there is no way to get THIS 'Secure:secret-scope' in other
      ; code. This means that there is no way to reference
      ; 'inner-scope' with the special scope from the 'letrec' from
      ; anywhere else other than in this library. Rules defined
      ; outside of this library CAN, of course, match on a DIFFERENT
      ; 'Secure:secret-scope', but it wouldn't be THIS
      ; 'Secure:secret-scope'. Again, to be clear, the reason this
      ; works is because of lexical scope. There's nothing fancy
      ; happening here---just a clever (?) use of scope-sets.

      (letrec [inner-scope inner-scope]
        inner-scope))

  The reduction of the above term (see the definition of 'begin' for
  more information about how 'def' works) would be the following:

    (letrec [Secure (let [Secure-impl unique-scope]
                      Secure-impl)]
      (attempt-to-leak secret))

Definition of [letrec]: Exactly the same as [let] except that the
reduction has <result>/RS+{S} instead of <result>/RS. This allows
<result> to refer to terms in <pattern>.

  Why both 'let' and 'letrec'? Because I want both of the following
  programs to work:

    (let [x 10]
      (let [x x]
        x))
    --> 10 ; OK: 10 is a fixed-point
    
    (let [x 10]
      (letrec [x x]
        x))
    --> x ; OK: x is a fixed-point

  More specifically, we need to be able to define terms like (Some $x)
  as fixed-points. You need letrec to do this:

    (let [(Some 10) (Some 10)]
      (Some 10))
    --> (Some 10)
    --> ERROR! No rule to re-write (Some x), but (Some x) is not a
        fixed-point.

    ; This is because the (Some 10) on the RHS does not have the scope
    ; that was added to the LHS and the body of the let.

  ... but we also want to be able to shadow rules, so 'let' is
  necessary.

Definition of [cache-in-store]: (cache-in-store $) ... TODO!

Definition of [begin]: If there does not exist a rule in the
environment whose pattern matches (begin/{} $ ...) (e.g., a rule that
begins with the symbol 'begin' in the top-level scope and matches
zero-or-more subterms (whatever they may be), then the following two
rules are defined in the environment:


    Definition of [begin:program]:

      (Rule$ (begin main = $side-effects
                    (def $pattern $result) ...)
             (letrec [$pattern $result] ...
                     [side-effects (run IO $side-effects)]
               (sequence side-effects 0 1)))

      (Rule (begin main = side-effects
                   (def side-effects get-line))
            (letrec [side-effects get-line]
                    []))

      main = side-effects
      (def side-effects get-line)
      -->
      (begin main = side-effects
             (def side-effects get-line))
      -->
      (letrec [side-effects get-line]
              [side-effects (run IO side-effects)]
        (sequence side-effects 0 1))
      --> ERROR! NONDETERMINISTIC RULES TO REWRITE 'side-effects'!

    This is why we need the 'rule-application-scope' (call it {b} for
    'begin' here, and call the scope that letrec adds {lr}):
    
      main/{} =/{} side-effects/{}
      (def/{} side-effects/{} get-line/{})/{}
      --> ; this transformation isn't a rule, the 'begin' was always
          ; 'implicitly' there, so there's no rule application scope
          ; added in this step.
      (begin/{} main/{} =/{} side-effects/{}
                (def/{} side-effects/{} get-line/{})/{})/{}
      -->
      (letrec/{} [side-effects/{b,lr} get-line/{b,lr}]/{}
                 [side-effects/{lr} (run/{lr} IO/{lr} side-effects/{b,lr})/{lr}]/{}
        (sequence/{lr} side-effects/{lr} 0/{lr} 1/{lr})/{lr})/{}
      -->
      (sequence/{lr} side-effects/{lr} 0/{lr} 1/{lr})/{lr}
      -->
      (sequence/{lr} (run/{lr} IO/{lr} side-effects/{b,lr})/{lr}
                     0 1)
      -->
      (sequence/{lr} (run/{lr} IO/{lr} get-line/{b,lr}) 0 1)
      --> ; assume rule [get-line/{} (IO/{} builtins.get-line/{})/{}]/{} exists.
          ; Call its rule-application-scope 'g'.
      (sequence/{lr} (run/{lr} ))

;;;;;

      main = 

      (Rule (begin main = $side-effects
                   (def $pattern $result) ...)          
            (sequence $side-effects
                      (letrec [$pattern $result] ... 0)
                      1))
   
    Definition of [begin:library]:
    
      (Rule (begin (export $rule ...)
                   (def $pattern $result) ...)
            (let [$pattern $result] ...
                 [exports (Env $rule ...)]
              (cache-in-store exports)))


  
  The language environment, when running code, wraps the entire file
  in (begin ....). This 'default' implementation of 'begin' just
  reduces boilerplate:
  
    ; my-file.lang
    
    (factorial 10)
  
    (def (factorial $n) (factorial $n 1))
    (def (factorial $n $acc)
      (if (= $n 0)
          acc
  	(factorial (- $n 1)
  	           (* $n $acc))))
  
  This would get compiled as:
  
    (letrec [(factorial $n) (factorial $n 1)]
            [(factorial $n $acc)
             (if (= $n 0)
                 acc
                  (factorial (- $n 1)
                             (* $n $acc)))]
      (factorial 10))
  
  Which avoids the need to explicitly write everything in a 'letrec'.
  
  And if you wanted to implement your own way of restructuring programs,
  you could simply write a new (Rule (begin ....) ....) in the top-level
  scope and supply it in every environment in which you want to run
  code.
  
  'begin' is kind of like a blending of '#%module-begin' and 'begin0' in
  racket.
  
  Note: This 'default begin' is still available in nested scopes, so if
  you wanted to write 'def' inside of a 'let', you could do so:
  
    (let [food "pizza"]
      (begin (make-crazy food)
        (def (make-crazy $food)
          (make-crazier (+ "ice cream" " " $food)))
        (def (make-crazier $food)
          (+ "chocolate covered" " " $food))))
    -->
    (begin (make-crazy food)
      (def (make-crazy $food)
        (make-crazier (+ "ice cream" " " $food)))
      (def (make-crazier $food)
        (+ "chocolate covered" " " $food)))
    -->
    (letrec [(make-crazy $food)
             (make-crazier (+ "ice cream" " " $food))]
            [(make-crazier $food)
             (+ "chocolate covered" " " $food)]
      (make-crazy food))
    -->
    (make-crazy food)
    -->
    (make-crazier (+ "ice cream" " " food))
    -->
    (+ "chocolate covered"
       (+ "ice cream" " " food))
    -->
    (+ "chocolate covered" " "
       (+ "ice cream" " " "pizza"))
    -->
    (+ "chocolate covered" " " "ice cream pizza")
    -->
    "chocolate covered ice cream pizza" ; OK: reached a fixed-point.

Definition of [undefined]: There exists a term, 'undefined', which is
not a fixed-point and does not reduce to a fixed-point.

Definition of [unsequence]: (unsequence <reduce-me> <if-successful>
<if-fails>) is defined as <if-successful> IF <reduce-me> CAN BE
reduced to a fixed-point. If <reduce-me> reduces to a term Q to which
there are no available rules for rewriting Q, the 'unsequence' form is
defined as <if-fails>.

  IMPORTANT! WARNING! The order of reduction of <reduce-me>,
  <if-successful>, and <if-fails> is not specified. An implementation
  could, potentially, try to reduce them all in parallel. To sequence
  reductions that have side effects (which may be provided by an
  implementation) use 'sequence'.

Definition of [sequence]: (sequence <reduce-me> <if-successful>
<if-fails>) is defined as <if-successful> WHEN <reduce-me> IS reduced
to a fixed-point. If <reduce-me> reduces to a term Q to which there
are no available rules for rewriting Q, the 'sequence' form is defined
as <if-fails>.

  Note: the reduction order is defined as follows.

    1. Attempt to reduce <reduce-me> to a fixed-point.

    2. If (1) worked, reduce to <if-successful>.

    3. If (1) failed, reduce to <if-fails>.

  It is defined that AT MOST ONE of <if-successful> OR <if-fails> will
  be reduced (any amount). (AT MOST ONE because the reduction of
  <reduce-me> may never halt).

    (begin (reduce-in-order (print document.txt-contents)
                            (delete document.txt-filename))
      (def (reduce-in-order $term1 $term2)
        (sequence $term1 $term2 undefined))
      (def document.txt-contents
        (lang.stdlib.impure.read-file document.txt-filename))
      (def (delete $file)
        (lang.stdlib.impure.delete-file $file))
      (def document.txt-filename "document.txt"))
     
    (letrec [doc (lang.stdlib.impure.read-file "document.txt")]
         [print-doc-content
      (sequence
       doc
       (begin print&delete
         (def print&delete
           (sequence
            (builtins.stdlib.impure.print doc)
             (builtins.stdlib.impure.delete-file "document.txt")
             undefined)))
       undefined))
    -->
    (sequence
     doc
     (begin print&delete
       (def print&delete
         (sequence (builtins.stdlib.impure.print doc)
                   (builtins.stdlib.impure.delete-file "document.txt")
                   undefined)))
     undefined)
    -->
    (sequence
     <document-contents>
     (begin print&delete
       (def print&delete
         (sequence (builtins.stdlib.impure.print <document-contents>)
                   (builtins.stdlib.impure.delete-file "document.txt")
                   undefined)))
     undefined)

FIXME! remove?

 ;;; Definitions of [fence-accept] [fence-release]: (fence-release <T>)
 ;;; reduces to <T> (it is the identity function). (fence-accept <T>)
 ;;; reduces to <T> if and only if (fence-release <T>) has already been
 ;;; reduced to a fixed-point. If (fence-release <T>) reduces to a term Q
 ;;; where there are no rules for rewriting Q, (fence-accept <T>) is
 ;;; defined as [undefined].
 ;;; 
 ;;;    This is useful for ordering the reduction of terms that have side
 ;;;    effects. Here's an example of using fences to do the following in
 ;;;    this order: (1) read a file; (2) print its contents and delete
 ;;;    it. Note that the example does not specify the order of printing
 ;;;    and deleting, just that it will have read the file before it does
 ;;;    either of those things.
 ;;; 
 ;;;    Also, for the purposes here, assume that '(builtins.stdlib.impure.*
 ;;;    ....)' forms reduce to fixed-points.
 ;;; 
 ;;;    (letrec [doc (lang.stdlib.impure.read-file "document.txt")]
 ;;;            [perform-read (fence-accept doc)]
 ;;;            [doc-contents (fence-release doc)]
 ;;;      (seq perform-read
 ;;;           (let [print&delete
 ;;;                 (seq (builtins.stdlib.impure.print doc-contents)
 ;;;                      (builtins.stdlib.impure.delete-file
 ;;;                       "document.txt")
 ;;;                      undefined)]
 ;;;             print&delete)
 ;;;           undefined))
 ;;;    -->
 ;;;    (seq perform-read
 ;;;         (let [print&delete
 ;;;               (seq (builtins.stdlib.impure.print doc-contents)
 ;;;                    (builtins.stdlib.impure.delete-file
 ;;;                     "document.txt")
 ;;;                    undefined)]
 ;;;           print&delete)
 ;;;         undefined)
 ;;; 
 ;;;    From this point, there are many possible ways that reduction can
 ;;;    occur. I will only consider the 'evil demon' implementation of
 ;;;    'seq' which tries to reduce itself in a way as to attempt to cause
 ;;;    as many concurrency errors as possible. In this case, I'll make it
 ;;;    reduce its second argument as far as it can, and only then reduce
 ;;;    its first argument.
 ;;; 
 ;;;    -->
 ;;;    (seq perform-read
 ;;;         print&delete
 ;;;         undefined)
 ;;;    -->
 ;;;    (seq perform-read
 ;;;         (seq (builtins.stdlib.impure.print doc-contents)
 ;;;              (builtins.stdlib.impure.delete-file
 ;;;               "document.txt")
 ;;;              undefined)
 ;;;         undefined)
 ;;;    -->
 ;;; 
 ;;; FIXME! move this after 'noreduce' and describe why it needs
 ;;; 'noreduce'. Definition of [freeze-pattern-scopes]:
 ;;; (freeze-pattern-scopes <R>) is defined if <R> reduces to a rule and
 ;;; the following condition holds: the scope-set of the pattern of <R> is
 ;;; a non-strict superset of the scope-set of the result of <R>. In other
 ;;; words, (freeze-pattern-scopes <R>) is not available in more-nested
 ;;; scopes.
 ;;; 
 ;;;   This is useful for implementing a Haskell-style IO Monad. Here we
 ;;;   want to write code that executes the IO Monad, but we only want this
 ;;;   to be done at the top-level (i.e., we don't want to allow reducing
 ;;;   the term (IO <X>) in a nested scope). For example, the following
 ;;;   code could be an implementation of 'begin' that would make a program
 ;;;   run in an environment containing the rule not able to use 'begin' in
 ;;;   a nested scope (to perform an IO action in a seemingly-pure
 ;;;   context):
 ;;; 
 ;;;   (freeze-pattern-scopes
 ;;;    (Rule (begin $main (def $pattern $result) ...)
 ;;;          (letrec [$pattern $result] ...
 ;;;            ; pretend that there exists a rule to re-write the
 ;;;            ; unsafe-perform-IO form to a series of 'sequence' forms.
 ;;;            (noreduce (unsafe-perform-IO $main)))))
 ;;; 
 ;;;   In an environment containing the previous rule, the following
 ;;;   reduction could occur:
 ;;; 
 ;;;   (let [doc (lang.stdlib.pure.read-file "document.txt")]
 ;;;     ; it would make sense here that (lang.stdlib.pure.read-file ....)
 ;;;     ; reduces to a fixed-point (IO <X>).
 ;;;     (begin doc))
 ;;;   --> (begin doc)
 ;;;   --> ERROR! No rules for rewriting '(begin doc)'. The closest is
 ;;;       '(begin $result (def $pattern $result) ...)', but that rule is
 ;;;       FROZEN as to not be available in more-nested scopes.
 ;;; 
 ;;; Definition of [noreduce]: The following rule exists in the top-level
 ;;; environment:
 ;;; 
 ;;;     (Rule (noreduce $) undefined)
 ;;; 
 ;;;   ... which is technically speaking an infinite series of rules---one
 ;;;   rule for each thing you could put in '$'---which ignores all of its
 ;;;   subterms and reduces to 'undefined'.
 ;;; 
 ;;;   This is useful for implementing pure rules using impure rules. While
 ;;;   purely-functional data structures are great, they can't do
 ;;;   everything. Sometimes the need for speed and space requires that we
 ;;;   use impurity. But it IS possible to write a rule that (1) doesn't
 ;;;   mutate its arguments, (2) always returns the same result for the
 ;;;   given arguments, and (3) uses mutation internally to do some
 ;;;   computation in a way that would be too slow or too space intensive
 ;;;   using purely-functional data structures. I think it would be
 ;;;   reasonable to call this rule 'pure', as the impurity inside of it is
 ;;;   merely an implementation detail of the rule; no one would know
 ;;;   otherwise if it was implemented using purely-functional data
 ;;;   structures (except that they might notice it taking longer to reduce
 ;;;   or taking more memory to reduce).
 ;;; 
 ;;;     ; For example, the implementation of a standard library could
 ;;;     ; contain the following rules which allow the creation of an
 ;;;     ; 'Internally-Mutable-Vector' that can't be reduced which is just
 ;;;     ; a wrapper around an (assuming) already-defined Mutable-Vector.
 ;;; 
 ;;;       mutable-vector-env+sequence-many-env
 ;;; 
 ;;;       (def mutable-vector-env+sequence-many-env
 ;;;         (Env m:new
 ;;;              m:mutable->immutable
 ;;;              m:set!
 ;;;              m:sequence-many1
 ;;;              m:sequence-many*))
 ;;; 
 ;;;       (def m:new
 ;;;         (Rule (new Internally-Mutable-Vector $size)
 ;;;           (begin (helper Internally-Mutable-Vector)
 ;;;             (def (helper $term-with-outside-scope)
 ;;;               (let
 ;;;                 (noreduce ($term-with-outside-scope (new lang.builtins.Mutable-Vector $size))))))))
 ;;; 
 ;;;       (def m:mutable->immutable
 ;;;         (Rule (mutable->immutable
 ;;;                (noreduce (Internally-Mutable-Vector $v)))
 ;;;               (mutable->immutable $v)))
 ;;;       
 ;;;       (def m:set!
 ;;;         (Rule (Internally-Mutable-Vector (noreduce $v))
 ;;;               $index
 ;;;               $value)
 ;;;           (set! $v $index $value))
 ;;; 
 ;;;       ; the following is useful for performing a lot of set!
 ;;;       ; operations:
 ;;;       (def m:sequence-many1
 ;;;         (Rule (sequence-many $term0) $term0))
 ;;;       (def m:sequence-many*
 ;;;         (Rule (sequence-many $term0 $terms ...+)
 ;;;           (sequence $term0
 ;;;                     (sequence-many $terms ...)
 ;;;                     undefined)))
 ;;; 
 ;;;     ; If these rules were present in our environment and we attempted
 ;;;     ; to return this 'Internally-Mutable-Vector', it wouldn't work:
 ;;; 
 ;;;       (let [v (new Internally-Mutable-Vector 2)]
 ;;;         (sequence-many (set! v 0 "a")
 ;;;                        (set! v 1 "b")
 ;;;                        v)) ; here we try to return 'v'
 ;;;       -->
 ;;;       (sequence-many (set! v 0 "a")
 ;;;                      (set! v 1 "b")
 ;;;                      v)
 ;;;       -->
 ;;;       (sequence (set! v 0 "a")
 ;;;                 (sequence-many (set! v 1 "b") v)
 ;;;                 undefined)
 ;;;       -->
 ;;;       (sequence (set! (new Internally-Mutable-Vector 2) 0 "a")
 ;;;                 (sequence-many (set! v 1 "b") v)
 ;;;                 undefined)
 ;;;       -->
 ;;;       (sequence (set! (noreduce (Internally-Mutable-Vector m)) 0 "a")
 ;;;                 (sequence-many (set! v 1 "b") v)
 ;;;                 undefined)
 ;;;       -->
 ;;;       (sequence (set! m 0 "a")
 ;;;                 (sequence-many (set! v 1 "b") v)
 ;;;                 undefined)
 ;;;       -->
 ;;;       (sequence (set! (new lang.builtins.Mutable-Vector 2) 0 "a")
 ;;;                 (sequence-many (set! v 1 "b") v)
 ;;;                 undefined)
 ;;;       --> ; assuming that 'new' rule on lang.builtins.Mutable-Vector
 ;;;           ; returns the fixed-point mutable vector representation
 ;;;           ; '<builtin-mut-vec>':
 ;;;       (sequence (set! <builtin-mut-vec> 0 "a")
 ;;;                 (sequence-many (set! v 1 "b") v)
 ;;;                 undefined)
 ;;;       --> ; assuming that the 'set!' rule on '<builtin-mut-vec>'
 ;;;           ; returns '<builtin-mut-vec>' itself after setting the value
 ;;;           ; at the index in the vector:
 ;;;       (sequence <builtin-mut-vec>
 ;;;                 (sequence-many (set! v 1 "b") v)
 ;;;                 undefined)
 ;;;       -->
 ;;;       (sequence-many (set! v 1 "b") v)
 ;;;       -->
 ;;;       (sequence (set! v 1 "b")
 ;;;                 (sequence-many v)
 ;;;                 undefined)
 ;;;       -- .... -->
 ;;;       (sequence (set! <builtin-mut-vec> 1 "b")
 ;;;                 (sequence-many v)
 ;;;                 undefined)
 ;;;       -->
 ;;;       (sequence-many v)
 ;;;       -->
 ;;;       v
 ;;;       --> ; at this point, due to sequencing, the mutable vector
 ;;;           ; inside of 'v' has already long been fully reduced to a
 ;;;           ; fixed-point, even though 'v' itself has not been. I'm
 ;;;           ; writing this to explain that even though 'v' reduces to
 ;;;           ; '(new Internally-Mutable-Vector 2)', it's not the case
 ;;;           ; that this creates a 'new' vector: it is the same one that
 ;;;           ; has been being mutated this whole time.
 ;;;       (new Internally-Mutable-Vector 2)
 ;;;       -->
 ;;;       (noreduce (Internally-Mutable-Vector m))
 ;;;       --> ; ERROR: attempt to REDUCE THE IRREDUCIBLE!
 ;;; 
 ;;;     ; But can't we 'break the system' by doing this?
 ;;; 
 ;;;       (def (impure-unwrap (Internally-Mutable-Vector (noreduce $v)))
 ;;;         $v)
 ;;; 
 ;;;       (let [v (new Internally-Mutable-Vector 2)]
 ;;;         (sequence-many (set! v 0 "a")
 ;;;                        (set! v 1 "b")
 ;;;                        (impure-unwrap v)))
 ;;;       -- .... -->
 ;;;       <builtin-mut-vec>
 ;;; 
 ;;;     ; Well, of course you can. But why would you?
 ;;;    
 ;;;     ; Here we will implement an algorithm that takes an integer N as
 ;;;     ; input and returns an immutable vector of size N, after filling
 ;;;     ; it with some data. Exactly what data goes in the vector is not
 ;;;     ; specified here, but filling the vector with data should involve
 ;;;     ; lots of expensive operations that would be hard to do in a
 ;;;     ; purely-functional way.
 ;;;     
 ;;;     (Rule (pure-algorithm $arg)
 ;;;           (pure-algorithm/internal-mutation $arg))
 ;;; 
 ;;;     (def (sequence-many $term0 $term ...+)
 ;;;       (sequence $term0
 ;;;                 (sequence-many $term ...)
 ;;;                 undefined))
 ;;; 
 ;;;     (def (pure-algorithm/internal-mutation $arg)
 ;;;       (let [v (new mutable-vector:internal $arg)]
 ;;;         (sequence v
 ;;;                   (begin (mutable-vector:internal->immutable-vector v)
 ;;;                     ....))))
 ;;; 
